"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_ssr_node_modules_locomotive-scroll_dist_locomotive-scroll_modern_mjs";
exports.ids = ["_ssr_node_modules_locomotive-scroll_dist_locomotive-scroll_modern_mjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/locomotive-scroll/dist/locomotive-scroll.modern.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/locomotive-scroll/dist/locomotive-scroll.modern.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LocomotiveScroll)\n/* harmony export */ });\n/* harmony import */ var _studio_freight_lenis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @studio-freight/lenis */ \"(ssr)/./node_modules/locomotive-scroll/node_modules/@studio-freight/lenis/dist/lenis.modern.mjs\");\n\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n/**\r\n * Intersection Observer\r\n *\r\n * Detecting visibility of an element in the viewport.\r\n *\r\n * Features functions to:\r\n *\r\n * - Trigger inview/outOfView callbacks\r\n * - If the element has a requestAnimationFrame dependency, set interactivy status for the ScrollElement Class\r\n *\r\n * References:\r\n *\r\n * - {@link https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API}\r\n */\nclass IO {\n  constructor({\n    scrollElements,\n    rootMargin = '-1px -1px -1px -1px',\n    IORaf\n  }) {\n    this.scrollElements = void 0;\n    this.rootMargin = void 0;\n    this.IORaf = void 0;\n    this.observer = void 0;\n    // Parameters\n    this.scrollElements = scrollElements;\n    this.rootMargin = rootMargin;\n    this.IORaf = IORaf;\n    // Init\n    this._init();\n  }\n  /**\r\n   * Lifecyle - Initialize Intersection Observer.\r\n   *\r\n   * @private\r\n   */\n  _init() {\n    // Options\n    const observerOptions = {\n      rootMargin: this.rootMargin\n    };\n    // Callback\n    const onIntersect = entries => {\n      entries.forEach(entry => {\n        const $targetItem = this.scrollElements.find(item => item.$el === entry.target);\n        if (entry.isIntersecting) {\n          $targetItem && ($targetItem.isAlreadyIntersected = true);\n          this._setInview(entry);\n        } else if ($targetItem && $targetItem.isAlreadyIntersected) {\n          this._setOutOfView(entry);\n        }\n      });\n    };\n    // Instance\n    this.observer = new IntersectionObserver(onIntersect, observerOptions);\n    // Observe each default elements\n    for (const scrollElement of this.scrollElements) {\n      const $scrollElement = scrollElement.$el;\n      this.observe($scrollElement);\n    }\n  }\n  /**\r\n   * Lifecyle - Destroy Intersection Observer.\r\n   */\n  destroy() {\n    this.observer.disconnect();\n  }\n  /**\r\n   * Subscribe element to the Intersection Observer.\r\n   *\r\n   * @param {HTMLElement} $scrollElement - DOM Element to observe.\r\n   */\n  observe($scrollElement) {\n    if (!$scrollElement) {\n      return;\n    }\n    this.observer.observe($scrollElement);\n  }\n  /**\r\n   * Unsubscribe element to the Intersection Observer.\r\n   *\r\n   * @param {HTMLElement} $scrollElement - DOM Element to unobserve.\r\n   */\n  unobserve($scrollElement) {\n    if (!$scrollElement) {\n      return;\n    }\n    this.observer.unobserve($scrollElement);\n  }\n  /**\r\n   * Find ScrollElementReference instance and trigger inview callbacks.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {IntersectionObserverEntry} entry - DOM Element to observe.\r\n   */\n  _setInview(entry) {\n    const scrollElement = this.scrollElements.find(scrollElement => scrollElement.$el === entry.target);\n    this.IORaf && (scrollElement == null ? void 0 : scrollElement.setInteractivityOn());\n    !this.IORaf && (scrollElement == null ? void 0 : scrollElement.setInview());\n  }\n  /**\r\n   * Find ScrollElementReference instance and trigger out of view callbacks.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {IntersectionObserverEntry} entry - DOM Element to observe.\r\n   */\n  _setOutOfView(entry) {\n    const scrollElement = this.scrollElements.find(scrollElement => scrollElement.$el === entry.target);\n    this.IORaf && (scrollElement == null ? void 0 : scrollElement.setInteractivityOff());\n    !this.IORaf && (scrollElement == null ? void 0 : scrollElement.setOutOfView());\n    // Unobserve if element doesn't have repeat attribute\n    if (!(scrollElement != null && scrollElement.attributes.scrollRepeat) && !this.IORaf) {\n      this.unobserve(entry.target);\n    }\n  }\n}\n\n// https://greensock.com/docs/v3/GSAP/gsap.utils\n/**\r\n * Clamp a value to fit within a specific range (ex: clamp(0, 100, -12) --> 0).\r\n *\r\n * @param {number} min   - Minimum value expected.\r\n * @param {number} max   - Maximum value expected.\r\n * @param {number} value - Current value.\r\n *\r\n * @returns {number} - Clamped value.\r\n */\nfunction clamp(min, max, value) {\n  return value < min ? min : value > max ? max : value;\n}\n/**\r\n * Map one range to another (ex: mapRange(-10, 10, 0, 100, 5) --> 75).\r\n *\r\n * @param {number} inMin  - Current minimum value.\r\n * @param {number} inMax  - Current maximum value.\r\n * @param {number} outMin - Maximum value expected.\r\n * @param {number} outMax - Maximum value expected.\r\n * @param {number} value  - Current value.\r\n *\r\n * @returns {number} - New value that should be between minimum value expected and maximum value.\r\n */\nfunction mapRange(inMin, inMax, outMin, outMax, value) {\n  const inRange = inMax - inMin;\n  const outRange = outMax - outMin;\n  return outMin + ((value - inMin) / inRange * outRange || 0);\n}\n/**\r\n * Map a number within a range to a progress between 0 to 1 (ex: normalize(100, 200, 150) --> 0.5).\r\n *\r\n * @param {number} min   - Current minimum value.\r\n * @param {number} max   - Current maximum value.\r\n * @param {number} value - Current value.\r\n *\r\n * @returns {number} - New value that should be between 0 and 1.\r\n */\nfunction normalize(min, max, value) {\n  return mapRange(min, max, 0, 1, value);\n}\n/**\r\n * Get closest number from an array.\r\n *\r\n * @param {number[]} array  - Numbers array.\r\n * @param {number}   target - Reference value.\r\n *\r\n * @returns {number} - Closest number.\r\n */\nfunction closestNumber(array, target) {\n  return array.reduce((prev, curr) => {\n    return Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev;\n  });\n}\n\n/**\r\n * Scroll Element\r\n *\r\n * Give tools to compute element progress in the viewport and triggers callbacks to animate it.\r\n *\r\n * Features functions to:\r\n *\r\n * - scrollClass - Add a custom class when the element is intersected by the offset\r\n * - scrollOffset - Determine offsets to intersect the element\r\n * - scrollPosition - Determine the element positions to consider an element as intersected.\r\n * - scrollModuleProgress - Send scroll progress to modular module that have a specific method (PROGRESS_MODULAR_METHOD)\r\n * - scrollCssProgress - Add a specific css variable (PROGRESS_CSS_VAR) that store the scroll progress\r\n * - scrollEventProgress - Send scroll progress to custom event listeners.\r\n * - scrollSpeed - Add a scroll multiplicator to create a parallax effect\r\n * - scrollRepeat - Repeat the option to trigger animation each time the element is intersected\r\n * - scrollCall - Call a custom event or a modular callback when the element is intersected\r\n */\n/** Constants */\nconst INVIEW_CLASS = 'is-inview';\nconst PROGRESS_CSS_VAR = '--progress';\nconst PROGRESS_MODULAR_METHOD = 'onScrollProgress';\nclass ScrollElement {\n  constructor({\n    $el,\n    id,\n    modularInstance,\n    subscribeElementUpdateFn,\n    unsubscribeElementUpdateFn,\n    needRaf,\n    scrollOrientation\n  }) {\n    var _this$$el$dataset$scr, _this$$el$dataset$scr2, _this$$el$dataset$scr3, _this$$el$dataset$scr4, _this$$el$dataset$scr5;\n    this.$el = void 0;\n    this.id = void 0;\n    this.needRaf = void 0;\n    this.attributes = void 0;\n    this.scrollOrientation = void 0;\n    this.isAlreadyIntersected = void 0;\n    this.intersection = void 0;\n    this.metrics = void 0;\n    this.currentScroll = void 0;\n    this.translateValue = void 0;\n    this.progress = void 0;\n    this.lastProgress = void 0;\n    this.modularInstance = void 0;\n    this.progressModularModules = void 0;\n    this.isInview = void 0;\n    this.isInteractive = void 0;\n    this.isInFold = void 0;\n    this.isFirstResize = void 0;\n    this.subscribeElementUpdateFn = void 0;\n    this.unsubscribeElementUpdateFn = void 0;\n    // Scroll DOM element\n    this.$el = $el;\n    // Unique ID\n    this.id = id;\n    // RAF option\n    this.needRaf = needRaf;\n    // Scroll Direction\n    this.scrollOrientation = scrollOrientation;\n    // Modular.js\n    this.modularInstance = modularInstance;\n    // Parent's callbacks\n    this.subscribeElementUpdateFn = subscribeElementUpdateFn;\n    this.unsubscribeElementUpdateFn = unsubscribeElementUpdateFn;\n    // Attributes\n    this.attributes = {\n      scrollClass: (_this$$el$dataset$scr = this.$el.dataset['scrollClass']) != null ? _this$$el$dataset$scr : INVIEW_CLASS,\n      scrollOffset: (_this$$el$dataset$scr2 = this.$el.dataset['scrollOffset']) != null ? _this$$el$dataset$scr2 : '0,0',\n      scrollPosition: (_this$$el$dataset$scr3 = this.$el.dataset['scrollPosition']) != null ? _this$$el$dataset$scr3 : 'start,end',\n      scrollModuleProgress: this.$el.dataset['scrollModuleProgress'] != null,\n      scrollCssProgress: this.$el.dataset['scrollCssProgress'] != null,\n      scrollEventProgress: (_this$$el$dataset$scr4 = this.$el.dataset['scrollEventProgress']) != null ? _this$$el$dataset$scr4 : null,\n      scrollSpeed: this.$el.dataset['scrollSpeed'] != null ? parseFloat(this.$el.dataset['scrollSpeed']) : null,\n      scrollRepeat: this.$el.dataset['scrollRepeat'] != null,\n      scrollCall: (_this$$el$dataset$scr5 = this.$el.dataset['scrollCall']) != null ? _this$$el$dataset$scr5 : null,\n      scrollCallSelf: this.$el.dataset['scrollCallSelf'] != null,\n      scrollIgnoreFold: this.$el.dataset['scrollIgnoreFold'] != null,\n      scrollEnableTouchSpeed: this.$el.dataset['scrollEnableTouchSpeed'] != null\n    };\n    // Limits\n    this.intersection = {\n      start: 0,\n      end: 0\n    };\n    // Metrics\n    this.metrics = {\n      offsetStart: 0,\n      offsetEnd: 0,\n      bcr: {}\n    };\n    // Scroll Values\n    this.currentScroll = this.scrollOrientation === 'vertical' ? window.scrollY : window.scrollX;\n    // Parallax\n    this.translateValue = 0;\n    // Progress\n    this.progress = 0;\n    this.lastProgress = null;\n    this.progressModularModules = [];\n    // Inview\n    this.isInview = false;\n    this.isInteractive = false;\n    this.isAlreadyIntersected = false;\n    this.isInFold = false;\n    this.isFirstResize = true;\n    // Init\n    this._init();\n  }\n  /**\r\n   * Lifecyle - Initialize progress tracking.\r\n   *\r\n   * @private\r\n   */\n  _init() {\n    if (!this.needRaf) {\n      return;\n    }\n    // Prepare modules progress\n    if (this.modularInstance && this.attributes.scrollModuleProgress) {\n      this._getProgressModularModules();\n    }\n    // First resize to compute all values\n    this._resize();\n  }\n  /**\r\n   * Callback - Resize callback\r\n   */\n  onResize({\n    currentScroll\n  }) {\n    this.currentScroll = currentScroll;\n    this._resize();\n  }\n  /**\r\n   * Callback - RAF callback\r\n   */\n  onRender({\n    currentScroll,\n    smooth\n  }) {\n    const wSize = this.scrollOrientation === 'vertical' ? window.innerHeight : window.innerWidth;\n    this.currentScroll = currentScroll;\n    this._computeProgress();\n    // Parallax\n    if (this.attributes.scrollSpeed && !isNaN(this.attributes.scrollSpeed)) {\n      // if touch detected or smooth disabled\n      if (!this.attributes.scrollEnableTouchSpeed && !smooth) {\n        if (this.translateValue) {\n          this.$el.style.transform = `translate3d(0, 0, 0)`;\n        }\n        this.translateValue = 0;\n        // if mousewheel or smooth enabled\n      } else {\n        // Check fold condition\n        if (this.isInFold) {\n          const progress = Math.max(0, this.progress);\n          this.translateValue = progress * wSize * this.attributes.scrollSpeed * -1;\n        } else {\n          const progress = mapRange(0, 1, -1, 1, this.progress);\n          this.translateValue = progress * wSize * this.attributes.scrollSpeed * -1;\n        }\n        this.$el.style.transform = this.scrollOrientation === 'vertical' ? `translate3d(0, ${this.translateValue}px, 0)` : `translate3d(${this.translateValue}px, 0, 0)`;\n      }\n    }\n  }\n  /**\r\n   * Inview callback\r\n   */\n  setInview() {\n    if (this.isInview) {\n      return;\n    }\n    this.isInview = true;\n    this.$el.classList.add(this.attributes.scrollClass);\n    const way = 'enter';\n    const from = this._getScrollCallFrom();\n    this.attributes.scrollCall && this._dispatchCall(way, from);\n  }\n  /**\r\n   * Out of view callback\r\n   */\n  setOutOfView() {\n    if (!(this.isInview && this.attributes.scrollRepeat)) {\n      return;\n    }\n    this.isInview = false;\n    this.$el.classList.remove(this.attributes.scrollClass);\n    const way = 'leave';\n    const from = this._getScrollCallFrom();\n    this.attributes.scrollCall && this._dispatchCall(way, from);\n  }\n  /**\r\n   * Switch interactivity on to subscribe the instance to the RAF\r\n   * and start calculations.\r\n   */\n  setInteractivityOn() {\n    if (this.isInteractive) {\n      return;\n    }\n    this.isInteractive = true;\n    this.subscribeElementUpdateFn(this);\n  }\n  /**\r\n   * Switch interactivity off to unsubscribe the instance to the RAF\r\n   * and stop calculations.\r\n   */\n  setInteractivityOff() {\n    if (!this.isInteractive) {\n      return;\n    }\n    this.isInteractive = false;\n    this.unsubscribeElementUpdateFn(this);\n    // Force progress to progress limit when the element is out\n    this.lastProgress != null && this._computeProgress(closestNumber([0, 1], this.lastProgress));\n  }\n  /**\r\n   * Resize method that compute the element's values.\r\n   *\r\n   * @private\r\n   */\n  _resize() {\n    this.metrics.bcr = this.$el.getBoundingClientRect();\n    this._computeMetrics();\n    this._computeIntersection();\n    // First resize logic\n    if (this.isFirstResize) {\n      this.isFirstResize = false;\n      // Dispatch default call if the element is in fold.\n      if (this.isInFold) {\n        this.setInview();\n      }\n    }\n  }\n  /**\r\n   * Compute element's offsets and determine if the element is in fold.\r\n   *\r\n   * @private\r\n   */\n  _computeMetrics() {\n    const {\n      top,\n      left,\n      height,\n      width\n    } = this.metrics.bcr;\n    const wSize = this.scrollOrientation === 'vertical' ? window.innerHeight : window.innerWidth;\n    const metricsStart = this.scrollOrientation === 'vertical' ? top : left;\n    const metricsSize = this.scrollOrientation === 'vertical' ? height : width;\n    this.metrics.offsetStart = this.currentScroll + metricsStart - this.translateValue;\n    this.metrics.offsetEnd = this.metrics.offsetStart + metricsSize;\n    if (this.metrics.offsetStart < wSize && !this.attributes.scrollIgnoreFold) {\n      this.isInFold = true;\n    } else {\n      this.isInFold = false;\n    }\n  }\n  /**\r\n   * Compute intersection values depending on the context.\r\n   *\r\n   * @private\r\n   */\n  _computeIntersection() {\n    // Window size\n    const wSize = this.scrollOrientation === 'vertical' ? window.innerHeight : window.innerWidth;\n    // Metrics size\n    const metricsSize = this.scrollOrientation === 'vertical' ? this.metrics.bcr.height : this.metrics.bcr.width;\n    // Offset\n    const offset = this.attributes.scrollOffset.split(',');\n    const offsetStart = offset[0] != undefined ? offset[0].trim() : '0';\n    const offsetEnd = offset[1] != undefined ? offset[1].trim() : '0';\n    // Positions\n    const scrollPosition = this.attributes.scrollPosition.split(',');\n    let scrollPositionStart = scrollPosition[0] != undefined ? scrollPosition[0].trim() : 'start';\n    const scrollPositionEnd = scrollPosition[1] != undefined ? scrollPosition[1].trim() : 'end';\n    // Viewport\n    const viewportStart = offsetStart.includes('%') ? wSize * parseInt(offsetStart.replace('%', '').trim()) * 0.01 : parseInt(offsetStart);\n    const viewportEnd = offsetEnd.includes('%') ? wSize * parseInt(offsetEnd.replace('%', '').trim()) * 0.01 : parseInt(offsetEnd);\n    // Fold exception\n    if (this.isInFold) {\n      scrollPositionStart = 'fold';\n    }\n    // Define Intersection Start\n    switch (scrollPositionStart) {\n      case 'start':\n        this.intersection.start = this.metrics.offsetStart - wSize + viewportStart;\n        break;\n      case 'middle':\n        this.intersection.start = this.metrics.offsetStart - wSize + viewportStart + metricsSize * 0.5;\n        break;\n      case 'end':\n        this.intersection.start = this.metrics.offsetStart - wSize + viewportStart + metricsSize;\n        break;\n      case 'fold':\n        this.intersection.start = 0;\n        break;\n      default:\n        this.intersection.start = this.metrics.offsetStart - wSize + viewportStart;\n        break;\n    }\n    // Define Intersection End\n    switch (scrollPositionEnd) {\n      case 'start':\n        this.intersection.end = this.metrics.offsetStart - viewportEnd;\n        break;\n      case 'middle':\n        this.intersection.end = this.metrics.offsetStart - viewportEnd + metricsSize * 0.5;\n        break;\n      case 'end':\n        this.intersection.end = this.metrics.offsetStart - viewportEnd + metricsSize;\n        break;\n      default:\n        this.intersection.end = this.metrics.offsetStart - viewportEnd + metricsSize;\n        break;\n    }\n    // Avoid to have the end < the start intersection >\n    if (this.intersection.end <= this.intersection.start) {\n      switch (scrollPositionEnd) {\n        case 'start':\n          this.intersection.end = this.intersection.start + 1;\n          break;\n        case 'middle':\n          this.intersection.end = this.intersection.start + metricsSize * 0.5;\n          break;\n        case 'end':\n          this.intersection.end = this.intersection.start + metricsSize;\n          break;\n        default:\n          this.intersection.end = this.intersection.start + 1;\n          break;\n      }\n    }\n  }\n  /**\r\n   * Compute the scroll progress of the element depending\r\n   * on its intersection values.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {number} [forcedProgress] - Value to force progress.\r\n   */\n  _computeProgress(forcedProgress) {\n    // Progress\n    const progress = forcedProgress != null ? forcedProgress : clamp(0, 1, normalize(this.intersection.start, this.intersection.end, this.currentScroll));\n    this.progress = progress;\n    if (progress != this.lastProgress) {\n      this.lastProgress = progress;\n      // Set the element's progress to the css variable\n      this.attributes.scrollCssProgress && this._setCssProgress(progress);\n      // Set the element's progress to the custom event listeners\n      this.attributes.scrollEventProgress && this._setCustomEventProgress(progress);\n      // Set the element's progress to inline modules\n      if (this.attributes.scrollModuleProgress) {\n        for (const modularModules of this.progressModularModules) {\n          this.modularInstance && this.modularInstance.call(PROGRESS_MODULAR_METHOD, progress, modularModules.moduleName, modularModules.moduleId);\n        }\n      }\n      // Logic to trigger the inview/out of view callbacks\n      progress > 0 && progress < 1 && this.setInview();\n      progress === 0 && this.setOutOfView();\n      progress === 1 && this.setOutOfView();\n    }\n  }\n  /**\r\n   * Set the element's progress to a specific css variable.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {number} [currentProgress] - Progress value.\r\n   */\n  _setCssProgress(currentProgress = 0) {\n    this.$el.style.setProperty(PROGRESS_CSS_VAR, currentProgress.toString());\n  }\n  /**\r\n   * Set the element's progress to the custom event listeners.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {number} [currentProgress] - Progress value.\r\n   */\n  _setCustomEventProgress(currentProgress = 0) {\n    const customEventName = this.attributes.scrollEventProgress;\n    if (!customEventName) return;\n    const customEvent = new CustomEvent(customEventName, {\n      detail: {\n        target: this.$el,\n        progress: currentProgress\n      }\n    });\n    window.dispatchEvent(customEvent);\n  }\n  /**\r\n   * Get modular modules that can listen the element's progress.\r\n   *\r\n   * @private\r\n   */\n  _getProgressModularModules() {\n    if (!this.modularInstance) {\n      return;\n    }\n    const modulesIdNames = Object.keys(this.$el.dataset).filter(key => key.includes('module'));\n    const modules = Object.entries(this.modularInstance.modules);\n    if (!modulesIdNames.length) {\n      return;\n    }\n    for (const modulesIdName of modulesIdNames) {\n      const moduleId = this.$el.dataset[modulesIdName];\n      if (!moduleId) {\n        return;\n      }\n      for (const module of modules) {\n        const [moduleName, moduleObj] = module;\n        if (moduleId in moduleObj) {\n          this.progressModularModules.push({\n            moduleName,\n            moduleId\n          });\n        }\n      }\n    }\n  }\n  /**\r\n   * Function to get scroll call from.\r\n   *\r\n   * @private\r\n   */\n  _getScrollCallFrom() {\n    const closestIntersectionValue = closestNumber([this.intersection.start, this.intersection.end], this.currentScroll);\n    return this.intersection.start === closestIntersectionValue ? 'start' : 'end';\n  }\n  /**\r\n   * Function to dispatch a custom event or call a modular callback.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {scrollCallWay} way - Enter or leave.\r\n   * @param {scrollCallFrom} from - Start or end.\r\n   */\n  _dispatchCall(way, from) {\n    var _this$attributes$scro, _this$attributes;\n    const callParameters = (_this$attributes$scro = this.attributes.scrollCall) == null ? void 0 : _this$attributes$scro.split(',');\n    const callSelf = (_this$attributes = this.attributes) == null ? void 0 : _this$attributes.scrollCallSelf;\n    if (callParameters && callParameters.length > 1) {\n      var _targetModuleId;\n      // Using Modular.js (https://github.com/modularorg/modularjs)\n      const [func, moduleName, moduleId] = callParameters;\n      let targetModuleId;\n      // If the module is set on the scroll element\n      if (callSelf) {\n        targetModuleId = this.$el.dataset[`module${moduleName.trim()}`];\n      } else {\n        targetModuleId = moduleId;\n      }\n      this.modularInstance && this.modularInstance.call(func.trim(), {\n        target: this.$el,\n        way,\n        from\n      }, moduleName.trim(), (_targetModuleId = targetModuleId) == null ? void 0 : _targetModuleId.trim());\n    } else if (callParameters) {\n      // Using CustomEvent API (https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent)\n      const [customEventName] = callParameters;\n      const customEvent = new CustomEvent(customEventName, {\n        detail: {\n          target: this.$el,\n          way,\n          from\n        }\n      });\n      window.dispatchEvent(customEvent);\n    }\n  }\n}\n\n/**\r\n * Integrates Lenis with Locomotive's built-in animation system\r\n */\n/** Defined attributes that need a requestAnimationFrame */\nconst ATTRIBUTES_THAT_NEED_RAF = ['scrollOffset', 'scrollPosition', 'scrollModuleProgress', 'scrollCssProgress', 'scrollEventProgress', 'scrollSpeed'];\n/** Default root margins */\nconst TRIGGER_ROOT_MARGIN = '-1px -1px -1px -1px';\nconst RAF_ROOT_MARGIN = '100% 100% 100% 100%'; // Add 100vh top/bottom && 100vw left/right to use a biggest value with data-scroll-speed\nclass Core {\n  constructor({\n    $el,\n    modularInstance,\n    triggerRootMargin,\n    rafRootMargin,\n    scrollOrientation\n  }) {\n    this.$scrollContainer = void 0;\n    this.modularInstance = void 0;\n    this.triggerRootMargin = void 0;\n    this.rafRootMargin = void 0;\n    this.scrollElements = void 0;\n    this.triggeredScrollElements = void 0;\n    this.RAFScrollElements = void 0;\n    this.scrollElementsToUpdate = void 0;\n    this.IOTriggerInstance = void 0;\n    this.IORafInstance = void 0;\n    this.scrollOrientation = void 0;\n    if (!$el) {\n      console.error('Please provide a DOM Element as scrollContainer');\n      return;\n    }\n    // Scroll container\n    this.$scrollContainer = $el;\n    // Modular.js\n    this.modularInstance = modularInstance;\n    // Scroll Direction\n    this.scrollOrientation = scrollOrientation;\n    // IO Margins\n    this.triggerRootMargin = triggerRootMargin != null ? triggerRootMargin : TRIGGER_ROOT_MARGIN;\n    this.rafRootMargin = rafRootMargin != null ? rafRootMargin : RAF_ROOT_MARGIN;\n    // ScrollElements arrays\n    this.scrollElements = [];\n    this.triggeredScrollElements = [];\n    this.RAFScrollElements = [];\n    this.scrollElementsToUpdate = [];\n    // Init\n    this._init();\n  }\n  /**\r\n   * Lifecyle - Initialize the core.\r\n   *\r\n   * @private\r\n   */\n  _init() {\n    const $scrollElements = this.$scrollContainer.querySelectorAll('[data-scroll]');\n    const $scrollElementsArr = Array.from($scrollElements);\n    this._subscribeScrollElements($scrollElementsArr);\n    // Trigger IO\n    this.IOTriggerInstance = new IO({\n      scrollElements: [...this.triggeredScrollElements],\n      rootMargin: this.triggerRootMargin,\n      IORaf: false\n    });\n    // Raf IO\n    this.IORafInstance = new IO({\n      scrollElements: [...this.RAFScrollElements],\n      rootMargin: this.rafRootMargin,\n      IORaf: true\n    });\n  }\n  /**\r\n   * Lifecyle - Destroy core.\r\n   */\n  destroy() {\n    this.IOTriggerInstance.destroy();\n    this.IORafInstance.destroy();\n    this._unsubscribeAllScrollElements();\n  }\n  /**\r\n   * Callback - Resize callback.\r\n   */\n  onResize({\n    currentScroll\n  }) {\n    for (const scrollElement of this.RAFScrollElements) {\n      scrollElement.onResize({\n        currentScroll\n      });\n    }\n  }\n  /**\r\n   * Callback - RAF callback.\r\n   */\n  onRender({\n    currentScroll,\n    smooth\n  }) {\n    for (const scrollElement of this.scrollElementsToUpdate) {\n      scrollElement.onRender({\n        currentScroll,\n        smooth\n      });\n    }\n  }\n  /**\r\n   * Remove items from lists of scroll elements and compute all new values.\r\n   *\r\n   * @param {HTMLElement} $oldContainer - HTMLElement that contains data-scroll elements to unsubscribe\r\n   */\n  removeScrollElements($oldContainer) {\n    const $scrollElementsToRemove = $oldContainer.querySelectorAll('[data-scroll]');\n    if (!$scrollElementsToRemove.length) return;\n    // 1. Remove from IO\n    for (let index = 0; index < this.triggeredScrollElements.length; index++) {\n      const scrollElement = this.triggeredScrollElements[index];\n      const $scrollElementsToRemoveArr = Array.from($scrollElementsToRemove);\n      if ($scrollElementsToRemoveArr.indexOf(scrollElement.$el) > -1) {\n        this.IOTriggerInstance.unobserve(scrollElement.$el);\n        this.triggeredScrollElements.splice(index, 1);\n      }\n    }\n    for (let index = 0; index < this.RAFScrollElements.length; index++) {\n      const scrollElement = this.RAFScrollElements[index];\n      const $scrollElementsToRemoveArr = Array.from($scrollElementsToRemove);\n      if ($scrollElementsToRemoveArr.indexOf(scrollElement.$el) > -1) {\n        this.IORafInstance.unobserve(scrollElement.$el);\n        this.RAFScrollElements.splice(index, 1);\n      }\n    }\n    // 2. Remove from scrollElementsToUpdate[] and scrollElements[]\n    $scrollElementsToRemove.forEach($scrollElement => {\n      const targetScrollElementToUpdate = this.scrollElementsToUpdate.find(scrollElement => scrollElement.$el === $scrollElement);\n      const targetScrollElement = this.scrollElements.find(scrollElement => scrollElement.$el === $scrollElement);\n      if (targetScrollElementToUpdate) {\n        this._unsubscribeElementUpdate(targetScrollElementToUpdate);\n      }\n      if (targetScrollElement) {\n        this.scrollElements = this.scrollElements.filter(scrollElementItem => scrollElementItem.id != targetScrollElement.id);\n      }\n    });\n  }\n  /**\r\n   * Add items to lists of scroll elements and compute all new values.\r\n   *\r\n   * @param {HTMLElement} $newContainer - HTMLElement that contains data-scroll elements to subscribe\r\n   */\n  addScrollElements($newContainer) {\n    // 3. Rebuild ScrollElements\n    const $scrollElements = $newContainer.querySelectorAll('[data-scroll]');\n    // 4. Get max scrollElement.id\n    const ids = [];\n    this.scrollElements.forEach(scrollElement => {\n      ids.push(scrollElement.id);\n    });\n    const maxID = Math.max(...ids);\n    const fromIndex = maxID + 1;\n    const $scrollElementsArr = Array.from($scrollElements);\n    this._subscribeScrollElements($scrollElementsArr, fromIndex, true);\n  }\n  /**\r\n   * Create a ScrollElement instance for each elements with\r\n   * `data-scroll` attribute.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {HTMLElement[]} $scrollElements - List of elements that need\r\n   *     to be regarded.\r\n   */\n  _subscribeScrollElements($scrollElements, fromIndex = 0, toObserve = false) {\n    // For each scroll element create a ScrollElement instance\n    for (let index = 0; index < $scrollElements.length; index++) {\n      const $scrollElement = $scrollElements[index];\n      const needRaf = this._checkRafNeeded($scrollElement);\n      const scrollElementInstance = new ScrollElement({\n        $el: $scrollElement,\n        id: fromIndex + index,\n        scrollOrientation: this.scrollOrientation,\n        modularInstance: this.modularInstance,\n        subscribeElementUpdateFn: this._subscribeElementUpdate.bind(this),\n        unsubscribeElementUpdateFn: this._unsubscribeElementUpdate.bind(this),\n        needRaf\n      });\n      // Push to common array\n      this.scrollElements.push(scrollElementInstance);\n      // Push to specific array\n      if (needRaf) {\n        this.RAFScrollElements.push(scrollElementInstance);\n        // Dynamic observe item\n        if (toObserve) {\n          this.IORafInstance.scrollElements.push(scrollElementInstance);\n          this.IORafInstance.observe(scrollElementInstance.$el);\n        }\n      } else {\n        this.triggeredScrollElements.push(scrollElementInstance);\n        // Dynamic observe item\n        if (toObserve) {\n          this.IOTriggerInstance.scrollElements.push(scrollElementInstance);\n          this.IOTriggerInstance.observe(scrollElementInstance.$el);\n        }\n      }\n    }\n  }\n  /**\r\n   * Clear all ScrollElement arrays.\r\n   *\r\n   * @private\r\n   */\n  _unsubscribeAllScrollElements() {\n    this.scrollElements = [];\n    this.RAFScrollElements = [];\n    this.triggeredScrollElements = [];\n    this.scrollElementsToUpdate = [];\n  }\n  /**\r\n   * Subscribe ScrollElement instance that needs to be updated.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {ScrollElement} scrollElement - ScrollElement instance inview\r\n   *     that needs to be updated.\r\n   */\n  _subscribeElementUpdate(scrollElement) {\n    this.scrollElementsToUpdate.push(scrollElement);\n  }\n  /**\r\n   * Unscribe ScrollElement instance that doesn't need to be updated.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {ScrollElement} scrollElement - The updated ScrollElement instance\r\n   *     out of view now.\r\n   */\n  _unsubscribeElementUpdate(scrollElement) {\n    this.scrollElementsToUpdate = this.scrollElementsToUpdate.filter(scrollElementToUpdate => scrollElementToUpdate.id != scrollElement.id);\n  }\n  /**\r\n   * Check if a DOM Element need a requestAnimationFrame to be used.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {HTMLElement} $scrollElement - The element that needs to be checked.\r\n   *\r\n   * @returns {boolean}\r\n   */\n  _checkRafNeeded($scrollElement) {\n    let attributesThatNeedRaf = [...ATTRIBUTES_THAT_NEED_RAF];\n    // Remove utils\n    const removeAttribute = attributeToRemove => {\n      attributesThatNeedRaf = attributesThatNeedRaf.filter(attribute => attribute != attributeToRemove);\n    };\n    // 1. Check scroll offset values\n    if ($scrollElement.dataset.scrollOffset) {\n      const value = $scrollElement.dataset.scrollOffset.split(',').map(test => test.replace('%', '').trim()).join(',');\n      if (value != '0,0') {\n        return true;\n      } else {\n        removeAttribute('scrollOffset');\n      }\n    } else {\n      removeAttribute('scrollOffset');\n    }\n    // 2. Check scroll position values\n    if ($scrollElement.dataset.scrollPosition) {\n      const value = $scrollElement.dataset.scrollPosition.trim();\n      if (value != 'top,bottom') {\n        return true;\n      } else {\n        removeAttribute('scrollPosition');\n      }\n    } else {\n      removeAttribute('scrollPosition');\n    }\n    // 3. Check scroll speed values\n    if ($scrollElement.dataset.scrollSpeed && !isNaN(parseFloat($scrollElement.dataset.scrollSpeed))) {\n      return true;\n    } else {\n      removeAttribute('scrollSpeed');\n    }\n    // 4. Check others attributes\n    for (const attribute of attributesThatNeedRaf) {\n      if (attribute in $scrollElement.dataset) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n/**\r\n * Resize Observer\r\n *\r\n * The Resize Observer API provides a performant mechanism by which code can monitor an element for changes to its size,\r\n * with notifications being delivered to the observer each time the size changes.\r\n *\r\n * Features functions to:\r\n *\r\n * - Trigger the resize callback if the specified element's size change.\r\n *\r\n * References:\r\n *\r\n * - {@link https://developer.mozilla.org/en-US/docs/Web/API/Resize_Observer_API}\r\n */\nclass RO {\n  constructor({\n    resizeElements,\n    resizeCallback = () => {}\n  }) {\n    this.$resizeElements = void 0;\n    this.isFirstObserve = void 0;\n    this.observer = void 0;\n    this.resizeCallback = void 0;\n    // Parameters\n    this.$resizeElements = resizeElements;\n    this.resizeCallback = resizeCallback;\n    // Flags\n    this.isFirstObserve = true;\n    // Init\n    this._init();\n  }\n  /**\r\n   * Lifecyle - Initialize Resize Observer.\r\n   *\r\n   * @private\r\n   */\n  _init() {\n    // Callback\n    const onResize = entries => {\n      var _this$resizeCallback;\n      !this.isFirstObserve && ((_this$resizeCallback = this.resizeCallback) == null ? void 0 : _this$resizeCallback.call(this));\n      this.isFirstObserve = false;\n    };\n    // Instance\n    this.observer = new ResizeObserver(onResize);\n    // Observe each default elements\n    for (const $resizeElement of this.$resizeElements) {\n      this.observer.observe($resizeElement);\n    }\n  }\n  /**\r\n   * Lifecyle - Destroy Resize Observer.\r\n   */\n  destroy() {\n    this.observer.disconnect();\n  }\n}\n\n/**\r\n * @type {ILenisOptions}\r\n */\nconst defaultLenisOptions = {\n  wrapper: window,\n  content: document.documentElement,\n  lerp: 0.1,\n  duration: 1.2,\n  orientation: 'vertical',\n  gestureOrientation: 'vertical',\n  smoothWheel: true,\n  smoothTouch: false,\n  wheelMultiplier: 1,\n  touchMultiplier: 2,\n  normalizeWheel: true,\n  easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)) // https://www.desmos.com/calculator/brs54l4xou\n};\n/**\r\n * Locomotive Scroll\r\n *\r\n * Detection of elements in viewport & smooth scrolling with parallax.\r\n *\r\n * Inspired by\r\n * {@link https://github.com/locomotivemtl/locomotive-scroll locomotive-scroll.js}\r\n * and built around\r\n * {@link https://github.com/studio-freight/lenis lenis.js}.\r\n */\nclass LocomotiveScroll {\n  constructor({\n    lenisOptions = {},\n    modularInstance,\n    triggerRootMargin,\n    rafRootMargin,\n    autoResize = true,\n    autoStart = true,\n    scrollCallback = () => {},\n    initCustomTicker,\n    destroyCustomTicker\n  } = {}) {\n    this.rafPlaying = void 0;\n    this.lenisInstance = void 0;\n    this.coreInstance = void 0;\n    this.lenisOptions = void 0;\n    this.modularInstance = void 0;\n    this.triggerRootMargin = void 0;\n    this.rafRootMargin = void 0;\n    this.rafInstance = void 0;\n    this.autoResize = void 0;\n    this.autoStart = void 0;\n    this.ROInstance = void 0;\n    this.initCustomTicker = void 0;\n    this.destroyCustomTicker = void 0;\n    this._onRenderBind = void 0;\n    this._onResizeBind = void 0;\n    this._onScrollToBind = void 0;\n    // Arguments\n    this.lenisOptions = _extends({}, defaultLenisOptions, lenisOptions);\n    Object.assign(this, {\n      lenisOptions,\n      modularInstance,\n      triggerRootMargin,\n      rafRootMargin,\n      autoResize,\n      autoStart,\n      scrollCallback,\n      initCustomTicker,\n      destroyCustomTicker\n    });\n    // Binding\n    this._onRenderBind = this._onRender.bind(this);\n    this._onScrollToBind = this._onScrollTo.bind(this);\n    this._onResizeBind = this._onResize.bind(this);\n    // Data\n    this.rafPlaying = false;\n    // Init\n    this._init();\n  }\n  /**\r\n   * Lifecyle - Initialize instance.\r\n   *\r\n   * @private\r\n   */\n  _init() {\n    var _this$lenisInstance;\n    // Create Lenis instance\n    this.lenisInstance = new _studio_freight_lenis__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n      wrapper: this.lenisOptions.wrapper,\n      content: this.lenisOptions.content,\n      lerp: this.lenisOptions.lerp,\n      duration: this.lenisOptions.duration,\n      orientation: this.lenisOptions.orientation,\n      gestureOrientation: this.lenisOptions.gestureOrientation,\n      smoothWheel: this.lenisOptions.smoothWheel,\n      smoothTouch: this.lenisOptions.smoothTouch,\n      wheelMultiplier: this.lenisOptions.wheelMultiplier,\n      touchMultiplier: this.lenisOptions.touchMultiplier,\n      normalizeWheel: this.lenisOptions.normalizeWheel,\n      easing: this.lenisOptions.easing\n    });\n    (_this$lenisInstance = this.lenisInstance) == null ? void 0 : _this$lenisInstance.on('scroll', this.scrollCallback);\n    // Add scroll direction attribute on body\n    document.documentElement.setAttribute('data-scroll-orientation', this.lenisInstance.options.orientation);\n    requestAnimationFrame(() => {\n      // Create Core Instance\n      this.coreInstance = new Core({\n        $el: this.lenisInstance.rootElement,\n        modularInstance: this.modularInstance,\n        triggerRootMargin: this.triggerRootMargin,\n        rafRootMargin: this.rafRootMargin,\n        scrollOrientation: this.lenisInstance.options.orientation\n      });\n      // Bind Events\n      this._bindEvents();\n      // RAF warning\n      if (this.initCustomTicker && !this.destroyCustomTicker) {\n        console.warn('initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble.');\n      } else if (!this.initCustomTicker && this.destroyCustomTicker) {\n        console.warn('destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble.');\n      }\n      // Start RAF\n      this.autoStart && this.start();\n    });\n  }\n  /**\r\n   * Lifecyle - Destroy instance.\r\n   */\n  destroy() {\n    // Stop raf\n    this.stop();\n    // Unbind Events\n    this._unbindEvents();\n    // Destroy Lenis\n    this.lenisInstance.destroy();\n    // Destroy Core\n    this.coreInstance.destroy();\n  }\n  /**\r\n   * Events - Subscribe events to listen.\r\n   */\n  _bindEvents() {\n    this._bindScrollToEvents();\n    if (this.autoResize) {\n      if ('ResizeObserver' in window) {\n        this.ROInstance = new RO({\n          resizeElements: [document.body],\n          resizeCallback: this._onResizeBind\n        });\n      } else {\n        window.addEventListener('resize', this._onResizeBind);\n      }\n    }\n  }\n  /**\r\n   * Events - Unsubscribe listened events.\r\n   */\n  _unbindEvents() {\n    this._unbindScrollToEvents();\n    if (this.autoResize) {\n      if ('ResizeObserver' in window) {\n        this.ROInstance && this.ROInstance.destroy();\n      } else {\n        window.removeEventListener('resize', this._onResizeBind);\n      }\n    }\n  }\n  /**\r\n   * Events - Subscribe scrollTo events to listen.\r\n   */\n  _bindScrollToEvents($container) {\n    const $rootContainer = $container ? $container : this.lenisInstance.rootElement;\n    const $scrollToElements = $rootContainer == null ? void 0 : $rootContainer.querySelectorAll('[data-scroll-to]');\n    ($scrollToElements == null ? void 0 : $scrollToElements.length) && $scrollToElements.forEach($el => {\n      $el.addEventListener('click', this._onScrollToBind, false);\n    });\n  }\n  /**\r\n   * Events - Unsubscribe scrollTo listened events.\r\n   */\n  _unbindScrollToEvents($container) {\n    const $rootContainer = $container ? $container : this.lenisInstance.rootElement;\n    const $scrollToElements = $rootContainer == null ? void 0 : $rootContainer.querySelectorAll('[data-scroll-to]');\n    ($scrollToElements == null ? void 0 : $scrollToElements.length) && $scrollToElements.forEach($el => {\n      $el.removeEventListener('click', this._onScrollToBind, false);\n    });\n  }\n  /**\r\n   * Callback - Resize callback.\r\n   */\n  _onResize() {\n    // Waiting the next frame to get the new current scroll value return by Lenis\n    requestAnimationFrame(() => {\n      var _this$coreInstance;\n      (_this$coreInstance = this.coreInstance) == null ? void 0 : _this$coreInstance.onResize({\n        currentScroll: this.lenisInstance.scroll\n      });\n    });\n  }\n  /**\r\n   * Callback - Render callback.\r\n   */\n  _onRender() {\n    var _this$lenisInstance2, _this$coreInstance2;\n    (_this$lenisInstance2 = this.lenisInstance) == null ? void 0 : _this$lenisInstance2.raf(Date.now());\n    (_this$coreInstance2 = this.coreInstance) == null ? void 0 : _this$coreInstance2.onRender({\n      currentScroll: this.lenisInstance.scroll,\n      smooth: this.lenisInstance.isSmooth\n    });\n  }\n  /**\r\n   * Callback - Scroll To callback.\r\n   */\n  _onScrollTo(event) {\n    var _event$currentTarget;\n    event.preventDefault();\n    const $target = (_event$currentTarget = event.currentTarget) != null ? _event$currentTarget : null;\n    if (!$target) return;\n    const target = $target.getAttribute('data-scroll-to-href') || $target.getAttribute('href');\n    const offset = $target.getAttribute('data-scroll-to-offset') || 0;\n    const duration = $target.getAttribute('data-scroll-to-duration') || this.lenisOptions.duration || defaultLenisOptions.duration;\n    target && this.scrollTo(target, {\n      offset: typeof offset === 'string' ? parseInt(offset) : offset,\n      duration: typeof duration === 'string' ? parseInt(duration) : duration\n    });\n  }\n  /**\r\n   * Start RequestAnimationFrame that active Lenis smooth and scroll progress.\r\n   */\n  start() {\n    if (this.rafPlaying) {\n      return;\n    }\n    this.rafPlaying = true;\n    this.initCustomTicker ? this.initCustomTicker(this._onRenderBind) : this._raf();\n  }\n  /**\r\n   * Stop RequestAnimationFrame that active Lenis smooth and scroll progress.\r\n   */\n  stop() {\n    if (!this.rafPlaying) {\n      return;\n    }\n    this.rafPlaying = false;\n    this.destroyCustomTicker ? this.destroyCustomTicker(this._onRenderBind) : this.rafInstance && cancelAnimationFrame(this.rafInstance);\n  }\n  /**\r\n   * Remove old scroll elements items and rebuild ScrollElements instances.\r\n   */\n  removeScrollElements($oldContainer) {\n    var _this$coreInstance3;\n    if (!$oldContainer) {\n      console.error('Please provide a DOM Element as $oldContainer');\n      return;\n    }\n    this._unbindScrollToEvents($oldContainer);\n    (_this$coreInstance3 = this.coreInstance) == null ? void 0 : _this$coreInstance3.removeScrollElements($oldContainer);\n  }\n  /**\r\n   * Add new scroll elements items and rebuild ScrollElements instances.\r\n   */\n  addScrollElements($newContainer) {\n    var _this$coreInstance4;\n    if (!$newContainer) {\n      console.error('Please provide a DOM Element as $newContainer');\n      return;\n    }\n    (_this$coreInstance4 = this.coreInstance) == null ? void 0 : _this$coreInstance4.addScrollElements($newContainer);\n    requestAnimationFrame(() => {\n      this._bindScrollToEvents($newContainer);\n    });\n  }\n  /**\r\n   * Trigger resize callback.\r\n   */\n  resize() {\n    this._onResizeBind();\n  }\n  /**\r\n   * Trigger scroll to callback.\r\n   */\n  scrollTo(target, options) {\n    var _this$lenisInstance3;\n    (_this$lenisInstance3 = this.lenisInstance) == null ? void 0 : _this$lenisInstance3.scrollTo(target, {\n      offset: options == null ? void 0 : options.offset,\n      lerp: options == null ? void 0 : options.lerp,\n      duration: options == null ? void 0 : options.duration,\n      immediate: options == null ? void 0 : options.immediate,\n      lock: options == null ? void 0 : options.lock,\n      force: options == null ? void 0 : options.force,\n      easing: options == null ? void 0 : options.easing,\n      onComplete: options == null ? void 0 : options.onComplete\n    });\n  }\n  /**\r\n   * RequestAnimationFrame that active Lenis smooth and scroll progress.\r\n   *\r\n   * @private\r\n   *\r\n   */\n  _raf() {\n    this._onRenderBind();\n    this.rafInstance = requestAnimationFrame(() => this._raf());\n  }\n}\n\n\n//# sourceMappingURL=locomotive-scroll.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbG9jb21vdGl2ZS1zY3JvbGwvZGlzdC9sb2NvbW90aXZlLXNjcm9sbC5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBDOztBQUUxQztBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyQkFBMkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkJBQTJCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLG9CQUFvQix5QkFBeUIsb0JBQW9CO0FBQzlKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2Q0FBNkM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUNBQXVDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUksdURBQXVEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkRBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVDO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL2xvY29tb3RpdmUtc2Nyb2xsL2Rpc3QvbG9jb21vdGl2ZS1zY3JvbGwubW9kZXJuLm1qcz81ZWI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMZW5pcyBmcm9tICdAc3R1ZGlvLWZyZWlnaHQvbGVuaXMnO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLyoqXHJcbiAqIEludGVyc2VjdGlvbiBPYnNlcnZlclxyXG4gKlxyXG4gKiBEZXRlY3RpbmcgdmlzaWJpbGl0eSBvZiBhbiBlbGVtZW50IGluIHRoZSB2aWV3cG9ydC5cclxuICpcclxuICogRmVhdHVyZXMgZnVuY3Rpb25zIHRvOlxyXG4gKlxyXG4gKiAtIFRyaWdnZXIgaW52aWV3L291dE9mVmlldyBjYWxsYmFja3NcclxuICogLSBJZiB0aGUgZWxlbWVudCBoYXMgYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZGVwZW5kZW5jeSwgc2V0IGludGVyYWN0aXZ5IHN0YXR1cyBmb3IgdGhlIFNjcm9sbEVsZW1lbnQgQ2xhc3NcclxuICpcclxuICogUmVmZXJlbmNlczpcclxuICpcclxuICogLSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ludGVyc2VjdGlvbl9PYnNlcnZlcl9BUEl9XHJcbiAqL1xuY2xhc3MgSU8ge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc2Nyb2xsRWxlbWVudHMsXG4gICAgcm9vdE1hcmdpbiA9ICctMXB4IC0xcHggLTFweCAtMXB4JyxcbiAgICBJT1JhZlxuICB9KSB7XG4gICAgdGhpcy5zY3JvbGxFbGVtZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLnJvb3RNYXJnaW4gPSB2b2lkIDA7XG4gICAgdGhpcy5JT1JhZiA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIC8vIFBhcmFtZXRlcnNcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnRzID0gc2Nyb2xsRWxlbWVudHM7XG4gICAgdGhpcy5yb290TWFyZ2luID0gcm9vdE1hcmdpbjtcbiAgICB0aGlzLklPUmFmID0gSU9SYWY7XG4gICAgLy8gSW5pdFxuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvKipcclxuICAgKiBMaWZlY3lsZSAtIEluaXRpYWxpemUgSW50ZXJzZWN0aW9uIE9ic2VydmVyLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cbiAgX2luaXQoKSB7XG4gICAgLy8gT3B0aW9uc1xuICAgIGNvbnN0IG9ic2VydmVyT3B0aW9ucyA9IHtcbiAgICAgIHJvb3RNYXJnaW46IHRoaXMucm9vdE1hcmdpblxuICAgIH07XG4gICAgLy8gQ2FsbGJhY2tcbiAgICBjb25zdCBvbkludGVyc2VjdCA9IGVudHJpZXMgPT4ge1xuICAgICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgY29uc3QgJHRhcmdldEl0ZW0gPSB0aGlzLnNjcm9sbEVsZW1lbnRzLmZpbmQoaXRlbSA9PiBpdGVtLiRlbCA9PT0gZW50cnkudGFyZ2V0KTtcbiAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgJHRhcmdldEl0ZW0gJiYgKCR0YXJnZXRJdGVtLmlzQWxyZWFkeUludGVyc2VjdGVkID0gdHJ1ZSk7XG4gICAgICAgICAgdGhpcy5fc2V0SW52aWV3KGVudHJ5KTtcbiAgICAgICAgfSBlbHNlIGlmICgkdGFyZ2V0SXRlbSAmJiAkdGFyZ2V0SXRlbS5pc0FscmVhZHlJbnRlcnNlY3RlZCkge1xuICAgICAgICAgIHRoaXMuX3NldE91dE9mVmlldyhlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gSW5zdGFuY2VcbiAgICB0aGlzLm9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKG9uSW50ZXJzZWN0LCBvYnNlcnZlck9wdGlvbnMpO1xuICAgIC8vIE9ic2VydmUgZWFjaCBkZWZhdWx0IGVsZW1lbnRzXG4gICAgZm9yIChjb25zdCBzY3JvbGxFbGVtZW50IG9mIHRoaXMuc2Nyb2xsRWxlbWVudHMpIHtcbiAgICAgIGNvbnN0ICRzY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudC4kZWw7XG4gICAgICB0aGlzLm9ic2VydmUoJHNjcm9sbEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBMaWZlY3lsZSAtIERlc3Ryb3kgSW50ZXJzZWN0aW9uIE9ic2VydmVyLlxyXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFN1YnNjcmliZSBlbGVtZW50IHRvIHRoZSBJbnRlcnNlY3Rpb24gT2JzZXJ2ZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAkc2Nyb2xsRWxlbWVudCAtIERPTSBFbGVtZW50IHRvIG9ic2VydmUuXHJcbiAgICovXG4gIG9ic2VydmUoJHNjcm9sbEVsZW1lbnQpIHtcbiAgICBpZiAoISRzY3JvbGxFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSgkc2Nyb2xsRWxlbWVudCk7XG4gIH1cbiAgLyoqXHJcbiAgICogVW5zdWJzY3JpYmUgZWxlbWVudCB0byB0aGUgSW50ZXJzZWN0aW9uIE9ic2VydmVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJHNjcm9sbEVsZW1lbnQgLSBET00gRWxlbWVudCB0byB1bm9ic2VydmUuXHJcbiAgICovXG4gIHVub2JzZXJ2ZSgkc2Nyb2xsRWxlbWVudCkge1xuICAgIGlmICghJHNjcm9sbEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlci51bm9ic2VydmUoJHNjcm9sbEVsZW1lbnQpO1xuICB9XG4gIC8qKlxyXG4gICAqIEZpbmQgU2Nyb2xsRWxlbWVudFJlZmVyZW5jZSBpbnN0YW5jZSBhbmQgdHJpZ2dlciBpbnZpZXcgY2FsbGJhY2tzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeX0gZW50cnkgLSBET00gRWxlbWVudCB0byBvYnNlcnZlLlxyXG4gICAqL1xuICBfc2V0SW52aWV3KGVudHJ5KSB7XG4gICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IHRoaXMuc2Nyb2xsRWxlbWVudHMuZmluZChzY3JvbGxFbGVtZW50ID0+IHNjcm9sbEVsZW1lbnQuJGVsID09PSBlbnRyeS50YXJnZXQpO1xuICAgIHRoaXMuSU9SYWYgJiYgKHNjcm9sbEVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHNjcm9sbEVsZW1lbnQuc2V0SW50ZXJhY3Rpdml0eU9uKCkpO1xuICAgICF0aGlzLklPUmFmICYmIChzY3JvbGxFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBzY3JvbGxFbGVtZW50LnNldEludmlldygpKTtcbiAgfVxuICAvKipcclxuICAgKiBGaW5kIFNjcm9sbEVsZW1lbnRSZWZlcmVuY2UgaW5zdGFuY2UgYW5kIHRyaWdnZXIgb3V0IG9mIHZpZXcgY2FsbGJhY2tzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeX0gZW50cnkgLSBET00gRWxlbWVudCB0byBvYnNlcnZlLlxyXG4gICAqL1xuICBfc2V0T3V0T2ZWaWV3KGVudHJ5KSB7XG4gICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IHRoaXMuc2Nyb2xsRWxlbWVudHMuZmluZChzY3JvbGxFbGVtZW50ID0+IHNjcm9sbEVsZW1lbnQuJGVsID09PSBlbnRyeS50YXJnZXQpO1xuICAgIHRoaXMuSU9SYWYgJiYgKHNjcm9sbEVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHNjcm9sbEVsZW1lbnQuc2V0SW50ZXJhY3Rpdml0eU9mZigpKTtcbiAgICAhdGhpcy5JT1JhZiAmJiAoc2Nyb2xsRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsRWxlbWVudC5zZXRPdXRPZlZpZXcoKSk7XG4gICAgLy8gVW5vYnNlcnZlIGlmIGVsZW1lbnQgZG9lc24ndCBoYXZlIHJlcGVhdCBhdHRyaWJ1dGVcbiAgICBpZiAoIShzY3JvbGxFbGVtZW50ICE9IG51bGwgJiYgc2Nyb2xsRWxlbWVudC5hdHRyaWJ1dGVzLnNjcm9sbFJlcGVhdCkgJiYgIXRoaXMuSU9SYWYpIHtcbiAgICAgIHRoaXMudW5vYnNlcnZlKGVudHJ5LnRhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9kb2NzL3YzL0dTQVAvZ3NhcC51dGlsc1xuLyoqXHJcbiAqIENsYW1wIGEgdmFsdWUgdG8gZml0IHdpdGhpbiBhIHNwZWNpZmljIHJhbmdlIChleDogY2xhbXAoMCwgMTAwLCAtMTIpIC0tPiAwKS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiAgIC0gTWluaW11bSB2YWx1ZSBleHBlY3RlZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IG1heCAgIC0gTWF4aW11bSB2YWx1ZSBleHBlY3RlZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gQ3VycmVudCB2YWx1ZS5cclxuICpcclxuICogQHJldHVybnMge251bWJlcn0gLSBDbGFtcGVkIHZhbHVlLlxyXG4gKi9cbmZ1bmN0aW9uIGNsYW1wKG1pbiwgbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiB2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlO1xufVxuLyoqXHJcbiAqIE1hcCBvbmUgcmFuZ2UgdG8gYW5vdGhlciAoZXg6IG1hcFJhbmdlKC0xMCwgMTAsIDAsIDEwMCwgNSkgLS0+IDc1KS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGluTWluICAtIEN1cnJlbnQgbWluaW11bSB2YWx1ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IGluTWF4ICAtIEN1cnJlbnQgbWF4aW11bSB2YWx1ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IG91dE1pbiAtIE1heGltdW0gdmFsdWUgZXhwZWN0ZWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRNYXggLSBNYXhpbXVtIHZhbHVlIGV4cGVjdGVkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgIC0gQ3VycmVudCB2YWx1ZS5cclxuICpcclxuICogQHJldHVybnMge251bWJlcn0gLSBOZXcgdmFsdWUgdGhhdCBzaG91bGQgYmUgYmV0d2VlbiBtaW5pbXVtIHZhbHVlIGV4cGVjdGVkIGFuZCBtYXhpbXVtIHZhbHVlLlxyXG4gKi9cbmZ1bmN0aW9uIG1hcFJhbmdlKGluTWluLCBpbk1heCwgb3V0TWluLCBvdXRNYXgsIHZhbHVlKSB7XG4gIGNvbnN0IGluUmFuZ2UgPSBpbk1heCAtIGluTWluO1xuICBjb25zdCBvdXRSYW5nZSA9IG91dE1heCAtIG91dE1pbjtcbiAgcmV0dXJuIG91dE1pbiArICgodmFsdWUgLSBpbk1pbikgLyBpblJhbmdlICogb3V0UmFuZ2UgfHwgMCk7XG59XG4vKipcclxuICogTWFwIGEgbnVtYmVyIHdpdGhpbiBhIHJhbmdlIHRvIGEgcHJvZ3Jlc3MgYmV0d2VlbiAwIHRvIDEgKGV4OiBub3JtYWxpemUoMTAwLCAyMDAsIDE1MCkgLS0+IDAuNSkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gICAtIEN1cnJlbnQgbWluaW11bSB2YWx1ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IG1heCAgIC0gQ3VycmVudCBtYXhpbXVtIHZhbHVlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBDdXJyZW50IHZhbHVlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIE5ldyB2YWx1ZSB0aGF0IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIDEuXHJcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKG1pbiwgbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gbWFwUmFuZ2UobWluLCBtYXgsIDAsIDEsIHZhbHVlKTtcbn1cbi8qKlxyXG4gKiBHZXQgY2xvc2VzdCBudW1iZXIgZnJvbSBhbiBhcnJheS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJbXX0gYXJyYXkgIC0gTnVtYmVycyBhcnJheS5cclxuICogQHBhcmFtIHtudW1iZXJ9ICAgdGFyZ2V0IC0gUmVmZXJlbmNlIHZhbHVlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIENsb3Nlc3QgbnVtYmVyLlxyXG4gKi9cbmZ1bmN0aW9uIGNsb3Nlc3ROdW1iZXIoYXJyYXksIHRhcmdldCkge1xuICByZXR1cm4gYXJyYXkucmVkdWNlKChwcmV2LCBjdXJyKSA9PiB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGN1cnIgLSB0YXJnZXQpIDwgTWF0aC5hYnMocHJldiAtIHRhcmdldCkgPyBjdXJyIDogcHJldjtcbiAgfSk7XG59XG5cbi8qKlxyXG4gKiBTY3JvbGwgRWxlbWVudFxyXG4gKlxyXG4gKiBHaXZlIHRvb2xzIHRvIGNvbXB1dGUgZWxlbWVudCBwcm9ncmVzcyBpbiB0aGUgdmlld3BvcnQgYW5kIHRyaWdnZXJzIGNhbGxiYWNrcyB0byBhbmltYXRlIGl0LlxyXG4gKlxyXG4gKiBGZWF0dXJlcyBmdW5jdGlvbnMgdG86XHJcbiAqXHJcbiAqIC0gc2Nyb2xsQ2xhc3MgLSBBZGQgYSBjdXN0b20gY2xhc3Mgd2hlbiB0aGUgZWxlbWVudCBpcyBpbnRlcnNlY3RlZCBieSB0aGUgb2Zmc2V0XHJcbiAqIC0gc2Nyb2xsT2Zmc2V0IC0gRGV0ZXJtaW5lIG9mZnNldHMgdG8gaW50ZXJzZWN0IHRoZSBlbGVtZW50XHJcbiAqIC0gc2Nyb2xsUG9zaXRpb24gLSBEZXRlcm1pbmUgdGhlIGVsZW1lbnQgcG9zaXRpb25zIHRvIGNvbnNpZGVyIGFuIGVsZW1lbnQgYXMgaW50ZXJzZWN0ZWQuXHJcbiAqIC0gc2Nyb2xsTW9kdWxlUHJvZ3Jlc3MgLSBTZW5kIHNjcm9sbCBwcm9ncmVzcyB0byBtb2R1bGFyIG1vZHVsZSB0aGF0IGhhdmUgYSBzcGVjaWZpYyBtZXRob2QgKFBST0dSRVNTX01PRFVMQVJfTUVUSE9EKVxyXG4gKiAtIHNjcm9sbENzc1Byb2dyZXNzIC0gQWRkIGEgc3BlY2lmaWMgY3NzIHZhcmlhYmxlIChQUk9HUkVTU19DU1NfVkFSKSB0aGF0IHN0b3JlIHRoZSBzY3JvbGwgcHJvZ3Jlc3NcclxuICogLSBzY3JvbGxFdmVudFByb2dyZXNzIC0gU2VuZCBzY3JvbGwgcHJvZ3Jlc3MgdG8gY3VzdG9tIGV2ZW50IGxpc3RlbmVycy5cclxuICogLSBzY3JvbGxTcGVlZCAtIEFkZCBhIHNjcm9sbCBtdWx0aXBsaWNhdG9yIHRvIGNyZWF0ZSBhIHBhcmFsbGF4IGVmZmVjdFxyXG4gKiAtIHNjcm9sbFJlcGVhdCAtIFJlcGVhdCB0aGUgb3B0aW9uIHRvIHRyaWdnZXIgYW5pbWF0aW9uIGVhY2ggdGltZSB0aGUgZWxlbWVudCBpcyBpbnRlcnNlY3RlZFxyXG4gKiAtIHNjcm9sbENhbGwgLSBDYWxsIGEgY3VzdG9tIGV2ZW50IG9yIGEgbW9kdWxhciBjYWxsYmFjayB3aGVuIHRoZSBlbGVtZW50IGlzIGludGVyc2VjdGVkXHJcbiAqL1xuLyoqIENvbnN0YW50cyAqL1xuY29uc3QgSU5WSUVXX0NMQVNTID0gJ2lzLWludmlldyc7XG5jb25zdCBQUk9HUkVTU19DU1NfVkFSID0gJy0tcHJvZ3Jlc3MnO1xuY29uc3QgUFJPR1JFU1NfTU9EVUxBUl9NRVRIT0QgPSAnb25TY3JvbGxQcm9ncmVzcyc7XG5jbGFzcyBTY3JvbGxFbGVtZW50IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgICRlbCxcbiAgICBpZCxcbiAgICBtb2R1bGFySW5zdGFuY2UsXG4gICAgc3Vic2NyaWJlRWxlbWVudFVwZGF0ZUZuLFxuICAgIHVuc3Vic2NyaWJlRWxlbWVudFVwZGF0ZUZuLFxuICAgIG5lZWRSYWYsXG4gICAgc2Nyb2xsT3JpZW50YXRpb25cbiAgfSkge1xuICAgIHZhciBfdGhpcyQkZWwkZGF0YXNldCRzY3IsIF90aGlzJCRlbCRkYXRhc2V0JHNjcjIsIF90aGlzJCRlbCRkYXRhc2V0JHNjcjMsIF90aGlzJCRlbCRkYXRhc2V0JHNjcjQsIF90aGlzJCRlbCRkYXRhc2V0JHNjcjU7XG4gICAgdGhpcy4kZWwgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLm5lZWRSYWYgPSB2b2lkIDA7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gdm9pZCAwO1xuICAgIHRoaXMuc2Nyb2xsT3JpZW50YXRpb24gPSB2b2lkIDA7XG4gICAgdGhpcy5pc0FscmVhZHlJbnRlcnNlY3RlZCA9IHZvaWQgMDtcbiAgICB0aGlzLmludGVyc2VjdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLm1ldHJpY3MgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyZW50U2Nyb2xsID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNsYXRlVmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5wcm9ncmVzcyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RQcm9ncmVzcyA9IHZvaWQgMDtcbiAgICB0aGlzLm1vZHVsYXJJbnN0YW5jZSA9IHZvaWQgMDtcbiAgICB0aGlzLnByb2dyZXNzTW9kdWxhck1vZHVsZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5pc0ludmlldyA9IHZvaWQgMDtcbiAgICB0aGlzLmlzSW50ZXJhY3RpdmUgPSB2b2lkIDA7XG4gICAgdGhpcy5pc0luRm9sZCA9IHZvaWQgMDtcbiAgICB0aGlzLmlzRmlyc3RSZXNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdWJzY3JpYmVFbGVtZW50VXBkYXRlRm4gPSB2b2lkIDA7XG4gICAgdGhpcy51bnN1YnNjcmliZUVsZW1lbnRVcGRhdGVGbiA9IHZvaWQgMDtcbiAgICAvLyBTY3JvbGwgRE9NIGVsZW1lbnRcbiAgICB0aGlzLiRlbCA9ICRlbDtcbiAgICAvLyBVbmlxdWUgSURcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgLy8gUkFGIG9wdGlvblxuICAgIHRoaXMubmVlZFJhZiA9IG5lZWRSYWY7XG4gICAgLy8gU2Nyb2xsIERpcmVjdGlvblxuICAgIHRoaXMuc2Nyb2xsT3JpZW50YXRpb24gPSBzY3JvbGxPcmllbnRhdGlvbjtcbiAgICAvLyBNb2R1bGFyLmpzXG4gICAgdGhpcy5tb2R1bGFySW5zdGFuY2UgPSBtb2R1bGFySW5zdGFuY2U7XG4gICAgLy8gUGFyZW50J3MgY2FsbGJhY2tzXG4gICAgdGhpcy5zdWJzY3JpYmVFbGVtZW50VXBkYXRlRm4gPSBzdWJzY3JpYmVFbGVtZW50VXBkYXRlRm47XG4gICAgdGhpcy51bnN1YnNjcmliZUVsZW1lbnRVcGRhdGVGbiA9IHVuc3Vic2NyaWJlRWxlbWVudFVwZGF0ZUZuO1xuICAgIC8vIEF0dHJpYnV0ZXNcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7XG4gICAgICBzY3JvbGxDbGFzczogKF90aGlzJCRlbCRkYXRhc2V0JHNjciA9IHRoaXMuJGVsLmRhdGFzZXRbJ3Njcm9sbENsYXNzJ10pICE9IG51bGwgPyBfdGhpcyQkZWwkZGF0YXNldCRzY3IgOiBJTlZJRVdfQ0xBU1MsXG4gICAgICBzY3JvbGxPZmZzZXQ6IChfdGhpcyQkZWwkZGF0YXNldCRzY3IyID0gdGhpcy4kZWwuZGF0YXNldFsnc2Nyb2xsT2Zmc2V0J10pICE9IG51bGwgPyBfdGhpcyQkZWwkZGF0YXNldCRzY3IyIDogJzAsMCcsXG4gICAgICBzY3JvbGxQb3NpdGlvbjogKF90aGlzJCRlbCRkYXRhc2V0JHNjcjMgPSB0aGlzLiRlbC5kYXRhc2V0WydzY3JvbGxQb3NpdGlvbiddKSAhPSBudWxsID8gX3RoaXMkJGVsJGRhdGFzZXQkc2NyMyA6ICdzdGFydCxlbmQnLFxuICAgICAgc2Nyb2xsTW9kdWxlUHJvZ3Jlc3M6IHRoaXMuJGVsLmRhdGFzZXRbJ3Njcm9sbE1vZHVsZVByb2dyZXNzJ10gIT0gbnVsbCxcbiAgICAgIHNjcm9sbENzc1Byb2dyZXNzOiB0aGlzLiRlbC5kYXRhc2V0WydzY3JvbGxDc3NQcm9ncmVzcyddICE9IG51bGwsXG4gICAgICBzY3JvbGxFdmVudFByb2dyZXNzOiAoX3RoaXMkJGVsJGRhdGFzZXQkc2NyNCA9IHRoaXMuJGVsLmRhdGFzZXRbJ3Njcm9sbEV2ZW50UHJvZ3Jlc3MnXSkgIT0gbnVsbCA/IF90aGlzJCRlbCRkYXRhc2V0JHNjcjQgOiBudWxsLFxuICAgICAgc2Nyb2xsU3BlZWQ6IHRoaXMuJGVsLmRhdGFzZXRbJ3Njcm9sbFNwZWVkJ10gIT0gbnVsbCA/IHBhcnNlRmxvYXQodGhpcy4kZWwuZGF0YXNldFsnc2Nyb2xsU3BlZWQnXSkgOiBudWxsLFxuICAgICAgc2Nyb2xsUmVwZWF0OiB0aGlzLiRlbC5kYXRhc2V0WydzY3JvbGxSZXBlYXQnXSAhPSBudWxsLFxuICAgICAgc2Nyb2xsQ2FsbDogKF90aGlzJCRlbCRkYXRhc2V0JHNjcjUgPSB0aGlzLiRlbC5kYXRhc2V0WydzY3JvbGxDYWxsJ10pICE9IG51bGwgPyBfdGhpcyQkZWwkZGF0YXNldCRzY3I1IDogbnVsbCxcbiAgICAgIHNjcm9sbENhbGxTZWxmOiB0aGlzLiRlbC5kYXRhc2V0WydzY3JvbGxDYWxsU2VsZiddICE9IG51bGwsXG4gICAgICBzY3JvbGxJZ25vcmVGb2xkOiB0aGlzLiRlbC5kYXRhc2V0WydzY3JvbGxJZ25vcmVGb2xkJ10gIT0gbnVsbCxcbiAgICAgIHNjcm9sbEVuYWJsZVRvdWNoU3BlZWQ6IHRoaXMuJGVsLmRhdGFzZXRbJ3Njcm9sbEVuYWJsZVRvdWNoU3BlZWQnXSAhPSBudWxsXG4gICAgfTtcbiAgICAvLyBMaW1pdHNcbiAgICB0aGlzLmludGVyc2VjdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZW5kOiAwXG4gICAgfTtcbiAgICAvLyBNZXRyaWNzXG4gICAgdGhpcy5tZXRyaWNzID0ge1xuICAgICAgb2Zmc2V0U3RhcnQ6IDAsXG4gICAgICBvZmZzZXRFbmQ6IDAsXG4gICAgICBiY3I6IHt9XG4gICAgfTtcbiAgICAvLyBTY3JvbGwgVmFsdWVzXG4gICAgdGhpcy5jdXJyZW50U2Nyb2xsID0gdGhpcy5zY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHdpbmRvdy5zY3JvbGxZIDogd2luZG93LnNjcm9sbFg7XG4gICAgLy8gUGFyYWxsYXhcbiAgICB0aGlzLnRyYW5zbGF0ZVZhbHVlID0gMDtcbiAgICAvLyBQcm9ncmVzc1xuICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuICAgIHRoaXMubGFzdFByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLnByb2dyZXNzTW9kdWxhck1vZHVsZXMgPSBbXTtcbiAgICAvLyBJbnZpZXdcbiAgICB0aGlzLmlzSW52aWV3ID0gZmFsc2U7XG4gICAgdGhpcy5pc0ludGVyYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5pc0FscmVhZHlJbnRlcnNlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNJbkZvbGQgPSBmYWxzZTtcbiAgICB0aGlzLmlzRmlyc3RSZXNpemUgPSB0cnVlO1xuICAgIC8vIEluaXRcbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogTGlmZWN5bGUgLSBJbml0aWFsaXplIHByb2dyZXNzIHRyYWNraW5nLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cbiAgX2luaXQoKSB7XG4gICAgaWYgKCF0aGlzLm5lZWRSYWYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUHJlcGFyZSBtb2R1bGVzIHByb2dyZXNzXG4gICAgaWYgKHRoaXMubW9kdWxhckluc3RhbmNlICYmIHRoaXMuYXR0cmlidXRlcy5zY3JvbGxNb2R1bGVQcm9ncmVzcykge1xuICAgICAgdGhpcy5fZ2V0UHJvZ3Jlc3NNb2R1bGFyTW9kdWxlcygpO1xuICAgIH1cbiAgICAvLyBGaXJzdCByZXNpemUgdG8gY29tcHV0ZSBhbGwgdmFsdWVzXG4gICAgdGhpcy5fcmVzaXplKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FsbGJhY2sgLSBSZXNpemUgY2FsbGJhY2tcclxuICAgKi9cbiAgb25SZXNpemUoe1xuICAgIGN1cnJlbnRTY3JvbGxcbiAgfSkge1xuICAgIHRoaXMuY3VycmVudFNjcm9sbCA9IGN1cnJlbnRTY3JvbGw7XG4gICAgdGhpcy5fcmVzaXplKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FsbGJhY2sgLSBSQUYgY2FsbGJhY2tcclxuICAgKi9cbiAgb25SZW5kZXIoe1xuICAgIGN1cnJlbnRTY3JvbGwsXG4gICAgc21vb3RoXG4gIH0pIHtcbiAgICBjb25zdCB3U2l6ZSA9IHRoaXMuc2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICB0aGlzLmN1cnJlbnRTY3JvbGwgPSBjdXJyZW50U2Nyb2xsO1xuICAgIHRoaXMuX2NvbXB1dGVQcm9ncmVzcygpO1xuICAgIC8vIFBhcmFsbGF4XG4gICAgaWYgKHRoaXMuYXR0cmlidXRlcy5zY3JvbGxTcGVlZCAmJiAhaXNOYU4odGhpcy5hdHRyaWJ1dGVzLnNjcm9sbFNwZWVkKSkge1xuICAgICAgLy8gaWYgdG91Y2ggZGV0ZWN0ZWQgb3Igc21vb3RoIGRpc2FibGVkXG4gICAgICBpZiAoIXRoaXMuYXR0cmlidXRlcy5zY3JvbGxFbmFibGVUb3VjaFNwZWVkICYmICFzbW9vdGgpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNsYXRlVmFsdWUpIHtcbiAgICAgICAgICB0aGlzLiRlbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoMCwgMCwgMClgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNsYXRlVmFsdWUgPSAwO1xuICAgICAgICAvLyBpZiBtb3VzZXdoZWVsIG9yIHNtb290aCBlbmFibGVkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDaGVjayBmb2xkIGNvbmRpdGlvblxuICAgICAgICBpZiAodGhpcy5pc0luRm9sZCkge1xuICAgICAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5tYXgoMCwgdGhpcy5wcm9ncmVzcyk7XG4gICAgICAgICAgdGhpcy50cmFuc2xhdGVWYWx1ZSA9IHByb2dyZXNzICogd1NpemUgKiB0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsU3BlZWQgKiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IG1hcFJhbmdlKDAsIDEsIC0xLCAxLCB0aGlzLnByb2dyZXNzKTtcbiAgICAgICAgICB0aGlzLnRyYW5zbGF0ZVZhbHVlID0gcHJvZ3Jlc3MgKiB3U2l6ZSAqIHRoaXMuYXR0cmlidXRlcy5zY3JvbGxTcGVlZCAqIC0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGVsLnN0eWxlLnRyYW5zZm9ybSA9IHRoaXMuc2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgPyBgdHJhbnNsYXRlM2QoMCwgJHt0aGlzLnRyYW5zbGF0ZVZhbHVlfXB4LCAwKWAgOiBgdHJhbnNsYXRlM2QoJHt0aGlzLnRyYW5zbGF0ZVZhbHVlfXB4LCAwLCAwKWA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEludmlldyBjYWxsYmFja1xyXG4gICAqL1xuICBzZXRJbnZpZXcoKSB7XG4gICAgaWYgKHRoaXMuaXNJbnZpZXcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc0ludmlldyA9IHRydWU7XG4gICAgdGhpcy4kZWwuY2xhc3NMaXN0LmFkZCh0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsQ2xhc3MpO1xuICAgIGNvbnN0IHdheSA9ICdlbnRlcic7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuX2dldFNjcm9sbENhbGxGcm9tKCk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzLnNjcm9sbENhbGwgJiYgdGhpcy5fZGlzcGF0Y2hDYWxsKHdheSwgZnJvbSk7XG4gIH1cbiAgLyoqXHJcbiAgICogT3V0IG9mIHZpZXcgY2FsbGJhY2tcclxuICAgKi9cbiAgc2V0T3V0T2ZWaWV3KCkge1xuICAgIGlmICghKHRoaXMuaXNJbnZpZXcgJiYgdGhpcy5hdHRyaWJ1dGVzLnNjcm9sbFJlcGVhdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc0ludmlldyA9IGZhbHNlO1xuICAgIHRoaXMuJGVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5hdHRyaWJ1dGVzLnNjcm9sbENsYXNzKTtcbiAgICBjb25zdCB3YXkgPSAnbGVhdmUnO1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLl9nZXRTY3JvbGxDYWxsRnJvbSgpO1xuICAgIHRoaXMuYXR0cmlidXRlcy5zY3JvbGxDYWxsICYmIHRoaXMuX2Rpc3BhdGNoQ2FsbCh3YXksIGZyb20pO1xuICB9XG4gIC8qKlxyXG4gICAqIFN3aXRjaCBpbnRlcmFjdGl2aXR5IG9uIHRvIHN1YnNjcmliZSB0aGUgaW5zdGFuY2UgdG8gdGhlIFJBRlxyXG4gICAqIGFuZCBzdGFydCBjYWxjdWxhdGlvbnMuXHJcbiAgICovXG4gIHNldEludGVyYWN0aXZpdHlPbigpIHtcbiAgICBpZiAodGhpcy5pc0ludGVyYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNJbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5zdWJzY3JpYmVFbGVtZW50VXBkYXRlRm4odGhpcyk7XG4gIH1cbiAgLyoqXHJcbiAgICogU3dpdGNoIGludGVyYWN0aXZpdHkgb2ZmIHRvIHVuc3Vic2NyaWJlIHRoZSBpbnN0YW5jZSB0byB0aGUgUkFGXHJcbiAgICogYW5kIHN0b3AgY2FsY3VsYXRpb25zLlxyXG4gICAqL1xuICBzZXRJbnRlcmFjdGl2aXR5T2ZmKCkge1xuICAgIGlmICghdGhpcy5pc0ludGVyYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNJbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMudW5zdWJzY3JpYmVFbGVtZW50VXBkYXRlRm4odGhpcyk7XG4gICAgLy8gRm9yY2UgcHJvZ3Jlc3MgdG8gcHJvZ3Jlc3MgbGltaXQgd2hlbiB0aGUgZWxlbWVudCBpcyBvdXRcbiAgICB0aGlzLmxhc3RQcm9ncmVzcyAhPSBudWxsICYmIHRoaXMuX2NvbXB1dGVQcm9ncmVzcyhjbG9zZXN0TnVtYmVyKFswLCAxXSwgdGhpcy5sYXN0UHJvZ3Jlc3MpKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXNpemUgbWV0aG9kIHRoYXQgY29tcHV0ZSB0aGUgZWxlbWVudCdzIHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIF9yZXNpemUoKSB7XG4gICAgdGhpcy5tZXRyaWNzLmJjciA9IHRoaXMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuX2NvbXB1dGVNZXRyaWNzKCk7XG4gICAgdGhpcy5fY29tcHV0ZUludGVyc2VjdGlvbigpO1xuICAgIC8vIEZpcnN0IHJlc2l6ZSBsb2dpY1xuICAgIGlmICh0aGlzLmlzRmlyc3RSZXNpemUpIHtcbiAgICAgIHRoaXMuaXNGaXJzdFJlc2l6ZSA9IGZhbHNlO1xuICAgICAgLy8gRGlzcGF0Y2ggZGVmYXVsdCBjYWxsIGlmIHRoZSBlbGVtZW50IGlzIGluIGZvbGQuXG4gICAgICBpZiAodGhpcy5pc0luRm9sZCkge1xuICAgICAgICB0aGlzLnNldEludmlldygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBDb21wdXRlIGVsZW1lbnQncyBvZmZzZXRzIGFuZCBkZXRlcm1pbmUgaWYgdGhlIGVsZW1lbnQgaXMgaW4gZm9sZC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIF9jb21wdXRlTWV0cmljcygpIHtcbiAgICBjb25zdCB7XG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgICAgaGVpZ2h0LFxuICAgICAgd2lkdGhcbiAgICB9ID0gdGhpcy5tZXRyaWNzLmJjcjtcbiAgICBjb25zdCB3U2l6ZSA9IHRoaXMuc2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBjb25zdCBtZXRyaWNzU3RhcnQgPSB0aGlzLnNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnID8gdG9wIDogbGVmdDtcbiAgICBjb25zdCBtZXRyaWNzU2l6ZSA9IHRoaXMuc2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgPyBoZWlnaHQgOiB3aWR0aDtcbiAgICB0aGlzLm1ldHJpY3Mub2Zmc2V0U3RhcnQgPSB0aGlzLmN1cnJlbnRTY3JvbGwgKyBtZXRyaWNzU3RhcnQgLSB0aGlzLnRyYW5zbGF0ZVZhbHVlO1xuICAgIHRoaXMubWV0cmljcy5vZmZzZXRFbmQgPSB0aGlzLm1ldHJpY3Mub2Zmc2V0U3RhcnQgKyBtZXRyaWNzU2l6ZTtcbiAgICBpZiAodGhpcy5tZXRyaWNzLm9mZnNldFN0YXJ0IDwgd1NpemUgJiYgIXRoaXMuYXR0cmlidXRlcy5zY3JvbGxJZ25vcmVGb2xkKSB7XG4gICAgICB0aGlzLmlzSW5Gb2xkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pc0luRm9sZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBDb21wdXRlIGludGVyc2VjdGlvbiB2YWx1ZXMgZGVwZW5kaW5nIG9uIHRoZSBjb250ZXh0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cbiAgX2NvbXB1dGVJbnRlcnNlY3Rpb24oKSB7XG4gICAgLy8gV2luZG93IHNpemVcbiAgICBjb25zdCB3U2l6ZSA9IHRoaXMuc2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAvLyBNZXRyaWNzIHNpemVcbiAgICBjb25zdCBtZXRyaWNzU2l6ZSA9IHRoaXMuc2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgPyB0aGlzLm1ldHJpY3MuYmNyLmhlaWdodCA6IHRoaXMubWV0cmljcy5iY3Iud2lkdGg7XG4gICAgLy8gT2Zmc2V0XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5hdHRyaWJ1dGVzLnNjcm9sbE9mZnNldC5zcGxpdCgnLCcpO1xuICAgIGNvbnN0IG9mZnNldFN0YXJ0ID0gb2Zmc2V0WzBdICE9IHVuZGVmaW5lZCA/IG9mZnNldFswXS50cmltKCkgOiAnMCc7XG4gICAgY29uc3Qgb2Zmc2V0RW5kID0gb2Zmc2V0WzFdICE9IHVuZGVmaW5lZCA/IG9mZnNldFsxXS50cmltKCkgOiAnMCc7XG4gICAgLy8gUG9zaXRpb25zXG4gICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsUG9zaXRpb24uc3BsaXQoJywnKTtcbiAgICBsZXQgc2Nyb2xsUG9zaXRpb25TdGFydCA9IHNjcm9sbFBvc2l0aW9uWzBdICE9IHVuZGVmaW5lZCA/IHNjcm9sbFBvc2l0aW9uWzBdLnRyaW0oKSA6ICdzdGFydCc7XG4gICAgY29uc3Qgc2Nyb2xsUG9zaXRpb25FbmQgPSBzY3JvbGxQb3NpdGlvblsxXSAhPSB1bmRlZmluZWQgPyBzY3JvbGxQb3NpdGlvblsxXS50cmltKCkgOiAnZW5kJztcbiAgICAvLyBWaWV3cG9ydFxuICAgIGNvbnN0IHZpZXdwb3J0U3RhcnQgPSBvZmZzZXRTdGFydC5pbmNsdWRlcygnJScpID8gd1NpemUgKiBwYXJzZUludChvZmZzZXRTdGFydC5yZXBsYWNlKCclJywgJycpLnRyaW0oKSkgKiAwLjAxIDogcGFyc2VJbnQob2Zmc2V0U3RhcnQpO1xuICAgIGNvbnN0IHZpZXdwb3J0RW5kID0gb2Zmc2V0RW5kLmluY2x1ZGVzKCclJykgPyB3U2l6ZSAqIHBhcnNlSW50KG9mZnNldEVuZC5yZXBsYWNlKCclJywgJycpLnRyaW0oKSkgKiAwLjAxIDogcGFyc2VJbnQob2Zmc2V0RW5kKTtcbiAgICAvLyBGb2xkIGV4Y2VwdGlvblxuICAgIGlmICh0aGlzLmlzSW5Gb2xkKSB7XG4gICAgICBzY3JvbGxQb3NpdGlvblN0YXJ0ID0gJ2ZvbGQnO1xuICAgIH1cbiAgICAvLyBEZWZpbmUgSW50ZXJzZWN0aW9uIFN0YXJ0XG4gICAgc3dpdGNoIChzY3JvbGxQb3NpdGlvblN0YXJ0KSB7XG4gICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLnN0YXJ0ID0gdGhpcy5tZXRyaWNzLm9mZnNldFN0YXJ0IC0gd1NpemUgKyB2aWV3cG9ydFN0YXJ0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLnN0YXJ0ID0gdGhpcy5tZXRyaWNzLm9mZnNldFN0YXJ0IC0gd1NpemUgKyB2aWV3cG9ydFN0YXJ0ICsgbWV0cmljc1NpemUgKiAwLjU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24uc3RhcnQgPSB0aGlzLm1ldHJpY3Mub2Zmc2V0U3RhcnQgLSB3U2l6ZSArIHZpZXdwb3J0U3RhcnQgKyBtZXRyaWNzU2l6ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmb2xkJzpcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24uc3RhcnQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLnN0YXJ0ID0gdGhpcy5tZXRyaWNzLm9mZnNldFN0YXJ0IC0gd1NpemUgKyB2aWV3cG9ydFN0YXJ0O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gRGVmaW5lIEludGVyc2VjdGlvbiBFbmRcbiAgICBzd2l0Y2ggKHNjcm9sbFBvc2l0aW9uRW5kKSB7XG4gICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLmVuZCA9IHRoaXMubWV0cmljcy5vZmZzZXRTdGFydCAtIHZpZXdwb3J0RW5kO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLmVuZCA9IHRoaXMubWV0cmljcy5vZmZzZXRTdGFydCAtIHZpZXdwb3J0RW5kICsgbWV0cmljc1NpemUgKiAwLjU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24uZW5kID0gdGhpcy5tZXRyaWNzLm9mZnNldFN0YXJ0IC0gdmlld3BvcnRFbmQgKyBtZXRyaWNzU2l6ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5lbmQgPSB0aGlzLm1ldHJpY3Mub2Zmc2V0U3RhcnQgLSB2aWV3cG9ydEVuZCArIG1ldHJpY3NTaXplO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gQXZvaWQgdG8gaGF2ZSB0aGUgZW5kIDwgdGhlIHN0YXJ0IGludGVyc2VjdGlvbiA+XG4gICAgaWYgKHRoaXMuaW50ZXJzZWN0aW9uLmVuZCA8PSB0aGlzLmludGVyc2VjdGlvbi5zdGFydCkge1xuICAgICAgc3dpdGNoIChzY3JvbGxQb3NpdGlvbkVuZCkge1xuICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24uZW5kID0gdGhpcy5pbnRlcnNlY3Rpb24uc3RhcnQgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLmVuZCA9IHRoaXMuaW50ZXJzZWN0aW9uLnN0YXJ0ICsgbWV0cmljc1NpemUgKiAwLjU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24uZW5kID0gdGhpcy5pbnRlcnNlY3Rpb24uc3RhcnQgKyBtZXRyaWNzU2l6ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5lbmQgPSB0aGlzLmludGVyc2VjdGlvbi5zdGFydCArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENvbXB1dGUgdGhlIHNjcm9sbCBwcm9ncmVzcyBvZiB0aGUgZWxlbWVudCBkZXBlbmRpbmdcclxuICAgKiBvbiBpdHMgaW50ZXJzZWN0aW9uIHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2ZvcmNlZFByb2dyZXNzXSAtIFZhbHVlIHRvIGZvcmNlIHByb2dyZXNzLlxyXG4gICAqL1xuICBfY29tcHV0ZVByb2dyZXNzKGZvcmNlZFByb2dyZXNzKSB7XG4gICAgLy8gUHJvZ3Jlc3NcbiAgICBjb25zdCBwcm9ncmVzcyA9IGZvcmNlZFByb2dyZXNzICE9IG51bGwgPyBmb3JjZWRQcm9ncmVzcyA6IGNsYW1wKDAsIDEsIG5vcm1hbGl6ZSh0aGlzLmludGVyc2VjdGlvbi5zdGFydCwgdGhpcy5pbnRlcnNlY3Rpb24uZW5kLCB0aGlzLmN1cnJlbnRTY3JvbGwpKTtcbiAgICB0aGlzLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgaWYgKHByb2dyZXNzICE9IHRoaXMubGFzdFByb2dyZXNzKSB7XG4gICAgICB0aGlzLmxhc3RQcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgLy8gU2V0IHRoZSBlbGVtZW50J3MgcHJvZ3Jlc3MgdG8gdGhlIGNzcyB2YXJpYWJsZVxuICAgICAgdGhpcy5hdHRyaWJ1dGVzLnNjcm9sbENzc1Byb2dyZXNzICYmIHRoaXMuX3NldENzc1Byb2dyZXNzKHByb2dyZXNzKTtcbiAgICAgIC8vIFNldCB0aGUgZWxlbWVudCdzIHByb2dyZXNzIHRvIHRoZSBjdXN0b20gZXZlbnQgbGlzdGVuZXJzXG4gICAgICB0aGlzLmF0dHJpYnV0ZXMuc2Nyb2xsRXZlbnRQcm9ncmVzcyAmJiB0aGlzLl9zZXRDdXN0b21FdmVudFByb2dyZXNzKHByb2dyZXNzKTtcbiAgICAgIC8vIFNldCB0aGUgZWxlbWVudCdzIHByb2dyZXNzIHRvIGlubGluZSBtb2R1bGVzXG4gICAgICBpZiAodGhpcy5hdHRyaWJ1dGVzLnNjcm9sbE1vZHVsZVByb2dyZXNzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxhck1vZHVsZXMgb2YgdGhpcy5wcm9ncmVzc01vZHVsYXJNb2R1bGVzKSB7XG4gICAgICAgICAgdGhpcy5tb2R1bGFySW5zdGFuY2UgJiYgdGhpcy5tb2R1bGFySW5zdGFuY2UuY2FsbChQUk9HUkVTU19NT0RVTEFSX01FVEhPRCwgcHJvZ3Jlc3MsIG1vZHVsYXJNb2R1bGVzLm1vZHVsZU5hbWUsIG1vZHVsYXJNb2R1bGVzLm1vZHVsZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTG9naWMgdG8gdHJpZ2dlciB0aGUgaW52aWV3L291dCBvZiB2aWV3IGNhbGxiYWNrc1xuICAgICAgcHJvZ3Jlc3MgPiAwICYmIHByb2dyZXNzIDwgMSAmJiB0aGlzLnNldEludmlldygpO1xuICAgICAgcHJvZ3Jlc3MgPT09IDAgJiYgdGhpcy5zZXRPdXRPZlZpZXcoKTtcbiAgICAgIHByb2dyZXNzID09PSAxICYmIHRoaXMuc2V0T3V0T2ZWaWV3KCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFNldCB0aGUgZWxlbWVudCdzIHByb2dyZXNzIHRvIGEgc3BlY2lmaWMgY3NzIHZhcmlhYmxlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY3VycmVudFByb2dyZXNzXSAtIFByb2dyZXNzIHZhbHVlLlxyXG4gICAqL1xuICBfc2V0Q3NzUHJvZ3Jlc3MoY3VycmVudFByb2dyZXNzID0gMCkge1xuICAgIHRoaXMuJGVsLnN0eWxlLnNldFByb3BlcnR5KFBST0dSRVNTX0NTU19WQVIsIGN1cnJlbnRQcm9ncmVzcy50b1N0cmluZygpKTtcbiAgfVxuICAvKipcclxuICAgKiBTZXQgdGhlIGVsZW1lbnQncyBwcm9ncmVzcyB0byB0aGUgY3VzdG9tIGV2ZW50IGxpc3RlbmVycy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2N1cnJlbnRQcm9ncmVzc10gLSBQcm9ncmVzcyB2YWx1ZS5cclxuICAgKi9cbiAgX3NldEN1c3RvbUV2ZW50UHJvZ3Jlc3MoY3VycmVudFByb2dyZXNzID0gMCkge1xuICAgIGNvbnN0IGN1c3RvbUV2ZW50TmFtZSA9IHRoaXMuYXR0cmlidXRlcy5zY3JvbGxFdmVudFByb2dyZXNzO1xuICAgIGlmICghY3VzdG9tRXZlbnROYW1lKSByZXR1cm47XG4gICAgY29uc3QgY3VzdG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoY3VzdG9tRXZlbnROYW1lLCB7XG4gICAgICBkZXRhaWw6IHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLiRlbCxcbiAgICAgICAgcHJvZ3Jlc3M6IGN1cnJlbnRQcm9ncmVzc1xuICAgICAgfVxuICAgIH0pO1xuICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGN1c3RvbUV2ZW50KTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgbW9kdWxhciBtb2R1bGVzIHRoYXQgY2FuIGxpc3RlbiB0aGUgZWxlbWVudCdzIHByb2dyZXNzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cbiAgX2dldFByb2dyZXNzTW9kdWxhck1vZHVsZXMoKSB7XG4gICAgaWYgKCF0aGlzLm1vZHVsYXJJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtb2R1bGVzSWROYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuJGVsLmRhdGFzZXQpLmZpbHRlcihrZXkgPT4ga2V5LmluY2x1ZGVzKCdtb2R1bGUnKSk7XG4gICAgY29uc3QgbW9kdWxlcyA9IE9iamVjdC5lbnRyaWVzKHRoaXMubW9kdWxhckluc3RhbmNlLm1vZHVsZXMpO1xuICAgIGlmICghbW9kdWxlc0lkTmFtZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgbW9kdWxlc0lkTmFtZSBvZiBtb2R1bGVzSWROYW1lcykge1xuICAgICAgY29uc3QgbW9kdWxlSWQgPSB0aGlzLiRlbC5kYXRhc2V0W21vZHVsZXNJZE5hbWVdO1xuICAgICAgaWYgKCFtb2R1bGVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVzKSB7XG4gICAgICAgIGNvbnN0IFttb2R1bGVOYW1lLCBtb2R1bGVPYmpdID0gbW9kdWxlO1xuICAgICAgICBpZiAobW9kdWxlSWQgaW4gbW9kdWxlT2JqKSB7XG4gICAgICAgICAgdGhpcy5wcm9ncmVzc01vZHVsYXJNb2R1bGVzLnB1c2goe1xuICAgICAgICAgICAgbW9kdWxlTmFtZSxcbiAgICAgICAgICAgIG1vZHVsZUlkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogRnVuY3Rpb24gdG8gZ2V0IHNjcm9sbCBjYWxsIGZyb20uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuICBfZ2V0U2Nyb2xsQ2FsbEZyb20oKSB7XG4gICAgY29uc3QgY2xvc2VzdEludGVyc2VjdGlvblZhbHVlID0gY2xvc2VzdE51bWJlcihbdGhpcy5pbnRlcnNlY3Rpb24uc3RhcnQsIHRoaXMuaW50ZXJzZWN0aW9uLmVuZF0sIHRoaXMuY3VycmVudFNjcm9sbCk7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0aW9uLnN0YXJ0ID09PSBjbG9zZXN0SW50ZXJzZWN0aW9uVmFsdWUgPyAnc3RhcnQnIDogJ2VuZCc7XG4gIH1cbiAgLyoqXHJcbiAgICogRnVuY3Rpb24gdG8gZGlzcGF0Y2ggYSBjdXN0b20gZXZlbnQgb3IgY2FsbCBhIG1vZHVsYXIgY2FsbGJhY2suXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzY3JvbGxDYWxsV2F5fSB3YXkgLSBFbnRlciBvciBsZWF2ZS5cclxuICAgKiBAcGFyYW0ge3Njcm9sbENhbGxGcm9tfSBmcm9tIC0gU3RhcnQgb3IgZW5kLlxyXG4gICAqL1xuICBfZGlzcGF0Y2hDYWxsKHdheSwgZnJvbSkge1xuICAgIHZhciBfdGhpcyRhdHRyaWJ1dGVzJHNjcm8sIF90aGlzJGF0dHJpYnV0ZXM7XG4gICAgY29uc3QgY2FsbFBhcmFtZXRlcnMgPSAoX3RoaXMkYXR0cmlidXRlcyRzY3JvID0gdGhpcy5hdHRyaWJ1dGVzLnNjcm9sbENhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRhdHRyaWJ1dGVzJHNjcm8uc3BsaXQoJywnKTtcbiAgICBjb25zdCBjYWxsU2VsZiA9IChfdGhpcyRhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkYXR0cmlidXRlcy5zY3JvbGxDYWxsU2VsZjtcbiAgICBpZiAoY2FsbFBhcmFtZXRlcnMgJiYgY2FsbFBhcmFtZXRlcnMubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIF90YXJnZXRNb2R1bGVJZDtcbiAgICAgIC8vIFVzaW5nIE1vZHVsYXIuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2R1bGFyb3JnL21vZHVsYXJqcylcbiAgICAgIGNvbnN0IFtmdW5jLCBtb2R1bGVOYW1lLCBtb2R1bGVJZF0gPSBjYWxsUGFyYW1ldGVycztcbiAgICAgIGxldCB0YXJnZXRNb2R1bGVJZDtcbiAgICAgIC8vIElmIHRoZSBtb2R1bGUgaXMgc2V0IG9uIHRoZSBzY3JvbGwgZWxlbWVudFxuICAgICAgaWYgKGNhbGxTZWxmKSB7XG4gICAgICAgIHRhcmdldE1vZHVsZUlkID0gdGhpcy4kZWwuZGF0YXNldFtgbW9kdWxlJHttb2R1bGVOYW1lLnRyaW0oKX1gXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldE1vZHVsZUlkID0gbW9kdWxlSWQ7XG4gICAgICB9XG4gICAgICB0aGlzLm1vZHVsYXJJbnN0YW5jZSAmJiB0aGlzLm1vZHVsYXJJbnN0YW5jZS5jYWxsKGZ1bmMudHJpbSgpLCB7XG4gICAgICAgIHRhcmdldDogdGhpcy4kZWwsXG4gICAgICAgIHdheSxcbiAgICAgICAgZnJvbVxuICAgICAgfSwgbW9kdWxlTmFtZS50cmltKCksIChfdGFyZ2V0TW9kdWxlSWQgPSB0YXJnZXRNb2R1bGVJZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXRNb2R1bGVJZC50cmltKCkpO1xuICAgIH0gZWxzZSBpZiAoY2FsbFBhcmFtZXRlcnMpIHtcbiAgICAgIC8vIFVzaW5nIEN1c3RvbUV2ZW50IEFQSSAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50KVxuICAgICAgY29uc3QgW2N1c3RvbUV2ZW50TmFtZV0gPSBjYWxsUGFyYW1ldGVycztcbiAgICAgIGNvbnN0IGN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGN1c3RvbUV2ZW50TmFtZSwge1xuICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMuJGVsLFxuICAgICAgICAgIHdheSxcbiAgICAgICAgICBmcm9tXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoY3VzdG9tRXZlbnQpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcclxuICogSW50ZWdyYXRlcyBMZW5pcyB3aXRoIExvY29tb3RpdmUncyBidWlsdC1pbiBhbmltYXRpb24gc3lzdGVtXHJcbiAqL1xuLyoqIERlZmluZWQgYXR0cmlidXRlcyB0aGF0IG5lZWQgYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKi9cbmNvbnN0IEFUVFJJQlVURVNfVEhBVF9ORUVEX1JBRiA9IFsnc2Nyb2xsT2Zmc2V0JywgJ3Njcm9sbFBvc2l0aW9uJywgJ3Njcm9sbE1vZHVsZVByb2dyZXNzJywgJ3Njcm9sbENzc1Byb2dyZXNzJywgJ3Njcm9sbEV2ZW50UHJvZ3Jlc3MnLCAnc2Nyb2xsU3BlZWQnXTtcbi8qKiBEZWZhdWx0IHJvb3QgbWFyZ2lucyAqL1xuY29uc3QgVFJJR0dFUl9ST09UX01BUkdJTiA9ICctMXB4IC0xcHggLTFweCAtMXB4JztcbmNvbnN0IFJBRl9ST09UX01BUkdJTiA9ICcxMDAlIDEwMCUgMTAwJSAxMDAlJzsgLy8gQWRkIDEwMHZoIHRvcC9ib3R0b20gJiYgMTAwdncgbGVmdC9yaWdodCB0byB1c2UgYSBiaWdnZXN0IHZhbHVlIHdpdGggZGF0YS1zY3JvbGwtc3BlZWRcbmNsYXNzIENvcmUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgJGVsLFxuICAgIG1vZHVsYXJJbnN0YW5jZSxcbiAgICB0cmlnZ2VyUm9vdE1hcmdpbixcbiAgICByYWZSb290TWFyZ2luLFxuICAgIHNjcm9sbE9yaWVudGF0aW9uXG4gIH0pIHtcbiAgICB0aGlzLiRzY3JvbGxDb250YWluZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5tb2R1bGFySW5zdGFuY2UgPSB2b2lkIDA7XG4gICAgdGhpcy50cmlnZ2VyUm9vdE1hcmdpbiA9IHZvaWQgMDtcbiAgICB0aGlzLnJhZlJvb3RNYXJnaW4gPSB2b2lkIDA7XG4gICAgdGhpcy5zY3JvbGxFbGVtZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLnRyaWdnZXJlZFNjcm9sbEVsZW1lbnRzID0gdm9pZCAwO1xuICAgIHRoaXMuUkFGU2Nyb2xsRWxlbWVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5zY3JvbGxFbGVtZW50c1RvVXBkYXRlID0gdm9pZCAwO1xuICAgIHRoaXMuSU9UcmlnZ2VySW5zdGFuY2UgPSB2b2lkIDA7XG4gICAgdGhpcy5JT1JhZkluc3RhbmNlID0gdm9pZCAwO1xuICAgIHRoaXMuc2Nyb2xsT3JpZW50YXRpb24gPSB2b2lkIDA7XG4gICAgaWYgKCEkZWwpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgRE9NIEVsZW1lbnQgYXMgc2Nyb2xsQ29udGFpbmVyJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFNjcm9sbCBjb250YWluZXJcbiAgICB0aGlzLiRzY3JvbGxDb250YWluZXIgPSAkZWw7XG4gICAgLy8gTW9kdWxhci5qc1xuICAgIHRoaXMubW9kdWxhckluc3RhbmNlID0gbW9kdWxhckluc3RhbmNlO1xuICAgIC8vIFNjcm9sbCBEaXJlY3Rpb25cbiAgICB0aGlzLnNjcm9sbE9yaWVudGF0aW9uID0gc2Nyb2xsT3JpZW50YXRpb247XG4gICAgLy8gSU8gTWFyZ2luc1xuICAgIHRoaXMudHJpZ2dlclJvb3RNYXJnaW4gPSB0cmlnZ2VyUm9vdE1hcmdpbiAhPSBudWxsID8gdHJpZ2dlclJvb3RNYXJnaW4gOiBUUklHR0VSX1JPT1RfTUFSR0lOO1xuICAgIHRoaXMucmFmUm9vdE1hcmdpbiA9IHJhZlJvb3RNYXJnaW4gIT0gbnVsbCA/IHJhZlJvb3RNYXJnaW4gOiBSQUZfUk9PVF9NQVJHSU47XG4gICAgLy8gU2Nyb2xsRWxlbWVudHMgYXJyYXlzXG4gICAgdGhpcy5zY3JvbGxFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMudHJpZ2dlcmVkU2Nyb2xsRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLlJBRlNjcm9sbEVsZW1lbnRzID0gW107XG4gICAgdGhpcy5zY3JvbGxFbGVtZW50c1RvVXBkYXRlID0gW107XG4gICAgLy8gSW5pdFxuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvKipcclxuICAgKiBMaWZlY3lsZSAtIEluaXRpYWxpemUgdGhlIGNvcmUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuICBfaW5pdCgpIHtcbiAgICBjb25zdCAkc2Nyb2xsRWxlbWVudHMgPSB0aGlzLiRzY3JvbGxDb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2Nyb2xsXScpO1xuICAgIGNvbnN0ICRzY3JvbGxFbGVtZW50c0FyciA9IEFycmF5LmZyb20oJHNjcm9sbEVsZW1lbnRzKTtcbiAgICB0aGlzLl9zdWJzY3JpYmVTY3JvbGxFbGVtZW50cygkc2Nyb2xsRWxlbWVudHNBcnIpO1xuICAgIC8vIFRyaWdnZXIgSU9cbiAgICB0aGlzLklPVHJpZ2dlckluc3RhbmNlID0gbmV3IElPKHtcbiAgICAgIHNjcm9sbEVsZW1lbnRzOiBbLi4udGhpcy50cmlnZ2VyZWRTY3JvbGxFbGVtZW50c10sXG4gICAgICByb290TWFyZ2luOiB0aGlzLnRyaWdnZXJSb290TWFyZ2luLFxuICAgICAgSU9SYWY6IGZhbHNlXG4gICAgfSk7XG4gICAgLy8gUmFmIElPXG4gICAgdGhpcy5JT1JhZkluc3RhbmNlID0gbmV3IElPKHtcbiAgICAgIHNjcm9sbEVsZW1lbnRzOiBbLi4udGhpcy5SQUZTY3JvbGxFbGVtZW50c10sXG4gICAgICByb290TWFyZ2luOiB0aGlzLnJhZlJvb3RNYXJnaW4sXG4gICAgICBJT1JhZjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIExpZmVjeWxlIC0gRGVzdHJveSBjb3JlLlxyXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuSU9UcmlnZ2VySW5zdGFuY2UuZGVzdHJveSgpO1xuICAgIHRoaXMuSU9SYWZJbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgdGhpcy5fdW5zdWJzY3JpYmVBbGxTY3JvbGxFbGVtZW50cygpO1xuICB9XG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIC0gUmVzaXplIGNhbGxiYWNrLlxyXG4gICAqL1xuICBvblJlc2l6ZSh7XG4gICAgY3VycmVudFNjcm9sbFxuICB9KSB7XG4gICAgZm9yIChjb25zdCBzY3JvbGxFbGVtZW50IG9mIHRoaXMuUkFGU2Nyb2xsRWxlbWVudHMpIHtcbiAgICAgIHNjcm9sbEVsZW1lbnQub25SZXNpemUoe1xuICAgICAgICBjdXJyZW50U2Nyb2xsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FsbGJhY2sgLSBSQUYgY2FsbGJhY2suXHJcbiAgICovXG4gIG9uUmVuZGVyKHtcbiAgICBjdXJyZW50U2Nyb2xsLFxuICAgIHNtb290aFxuICB9KSB7XG4gICAgZm9yIChjb25zdCBzY3JvbGxFbGVtZW50IG9mIHRoaXMuc2Nyb2xsRWxlbWVudHNUb1VwZGF0ZSkge1xuICAgICAgc2Nyb2xsRWxlbWVudC5vblJlbmRlcih7XG4gICAgICAgIGN1cnJlbnRTY3JvbGwsXG4gICAgICAgIHNtb290aFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJlbW92ZSBpdGVtcyBmcm9tIGxpc3RzIG9mIHNjcm9sbCBlbGVtZW50cyBhbmQgY29tcHV0ZSBhbGwgbmV3IHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICRvbGRDb250YWluZXIgLSBIVE1MRWxlbWVudCB0aGF0IGNvbnRhaW5zIGRhdGEtc2Nyb2xsIGVsZW1lbnRzIHRvIHVuc3Vic2NyaWJlXHJcbiAgICovXG4gIHJlbW92ZVNjcm9sbEVsZW1lbnRzKCRvbGRDb250YWluZXIpIHtcbiAgICBjb25zdCAkc2Nyb2xsRWxlbWVudHNUb1JlbW92ZSA9ICRvbGRDb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2Nyb2xsXScpO1xuICAgIGlmICghJHNjcm9sbEVsZW1lbnRzVG9SZW1vdmUubGVuZ3RoKSByZXR1cm47XG4gICAgLy8gMS4gUmVtb3ZlIGZyb20gSU9cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy50cmlnZ2VyZWRTY3JvbGxFbGVtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHNjcm9sbEVsZW1lbnQgPSB0aGlzLnRyaWdnZXJlZFNjcm9sbEVsZW1lbnRzW2luZGV4XTtcbiAgICAgIGNvbnN0ICRzY3JvbGxFbGVtZW50c1RvUmVtb3ZlQXJyID0gQXJyYXkuZnJvbSgkc2Nyb2xsRWxlbWVudHNUb1JlbW92ZSk7XG4gICAgICBpZiAoJHNjcm9sbEVsZW1lbnRzVG9SZW1vdmVBcnIuaW5kZXhPZihzY3JvbGxFbGVtZW50LiRlbCkgPiAtMSkge1xuICAgICAgICB0aGlzLklPVHJpZ2dlckluc3RhbmNlLnVub2JzZXJ2ZShzY3JvbGxFbGVtZW50LiRlbCk7XG4gICAgICAgIHRoaXMudHJpZ2dlcmVkU2Nyb2xsRWxlbWVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuUkFGU2Nyb2xsRWxlbWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBzY3JvbGxFbGVtZW50ID0gdGhpcy5SQUZTY3JvbGxFbGVtZW50c1tpbmRleF07XG4gICAgICBjb25zdCAkc2Nyb2xsRWxlbWVudHNUb1JlbW92ZUFyciA9IEFycmF5LmZyb20oJHNjcm9sbEVsZW1lbnRzVG9SZW1vdmUpO1xuICAgICAgaWYgKCRzY3JvbGxFbGVtZW50c1RvUmVtb3ZlQXJyLmluZGV4T2Yoc2Nyb2xsRWxlbWVudC4kZWwpID4gLTEpIHtcbiAgICAgICAgdGhpcy5JT1JhZkluc3RhbmNlLnVub2JzZXJ2ZShzY3JvbGxFbGVtZW50LiRlbCk7XG4gICAgICAgIHRoaXMuUkFGU2Nyb2xsRWxlbWVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gMi4gUmVtb3ZlIGZyb20gc2Nyb2xsRWxlbWVudHNUb1VwZGF0ZVtdIGFuZCBzY3JvbGxFbGVtZW50c1tdXG4gICAgJHNjcm9sbEVsZW1lbnRzVG9SZW1vdmUuZm9yRWFjaCgkc2Nyb2xsRWxlbWVudCA9PiB7XG4gICAgICBjb25zdCB0YXJnZXRTY3JvbGxFbGVtZW50VG9VcGRhdGUgPSB0aGlzLnNjcm9sbEVsZW1lbnRzVG9VcGRhdGUuZmluZChzY3JvbGxFbGVtZW50ID0+IHNjcm9sbEVsZW1lbnQuJGVsID09PSAkc2Nyb2xsRWxlbWVudCk7XG4gICAgICBjb25zdCB0YXJnZXRTY3JvbGxFbGVtZW50ID0gdGhpcy5zY3JvbGxFbGVtZW50cy5maW5kKHNjcm9sbEVsZW1lbnQgPT4gc2Nyb2xsRWxlbWVudC4kZWwgPT09ICRzY3JvbGxFbGVtZW50KTtcbiAgICAgIGlmICh0YXJnZXRTY3JvbGxFbGVtZW50VG9VcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVFbGVtZW50VXBkYXRlKHRhcmdldFNjcm9sbEVsZW1lbnRUb1VwZGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0U2Nyb2xsRWxlbWVudCkge1xuICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnRzID0gdGhpcy5zY3JvbGxFbGVtZW50cy5maWx0ZXIoc2Nyb2xsRWxlbWVudEl0ZW0gPT4gc2Nyb2xsRWxlbWVudEl0ZW0uaWQgIT0gdGFyZ2V0U2Nyb2xsRWxlbWVudC5pZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQWRkIGl0ZW1zIHRvIGxpc3RzIG9mIHNjcm9sbCBlbGVtZW50cyBhbmQgY29tcHV0ZSBhbGwgbmV3IHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICRuZXdDb250YWluZXIgLSBIVE1MRWxlbWVudCB0aGF0IGNvbnRhaW5zIGRhdGEtc2Nyb2xsIGVsZW1lbnRzIHRvIHN1YnNjcmliZVxyXG4gICAqL1xuICBhZGRTY3JvbGxFbGVtZW50cygkbmV3Q29udGFpbmVyKSB7XG4gICAgLy8gMy4gUmVidWlsZCBTY3JvbGxFbGVtZW50c1xuICAgIGNvbnN0ICRzY3JvbGxFbGVtZW50cyA9ICRuZXdDb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2Nyb2xsXScpO1xuICAgIC8vIDQuIEdldCBtYXggc2Nyb2xsRWxlbWVudC5pZFxuICAgIGNvbnN0IGlkcyA9IFtdO1xuICAgIHRoaXMuc2Nyb2xsRWxlbWVudHMuZm9yRWFjaChzY3JvbGxFbGVtZW50ID0+IHtcbiAgICAgIGlkcy5wdXNoKHNjcm9sbEVsZW1lbnQuaWQpO1xuICAgIH0pO1xuICAgIGNvbnN0IG1heElEID0gTWF0aC5tYXgoLi4uaWRzKTtcbiAgICBjb25zdCBmcm9tSW5kZXggPSBtYXhJRCArIDE7XG4gICAgY29uc3QgJHNjcm9sbEVsZW1lbnRzQXJyID0gQXJyYXkuZnJvbSgkc2Nyb2xsRWxlbWVudHMpO1xuICAgIHRoaXMuX3N1YnNjcmliZVNjcm9sbEVsZW1lbnRzKCRzY3JvbGxFbGVtZW50c0FyciwgZnJvbUluZGV4LCB0cnVlKTtcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgYSBTY3JvbGxFbGVtZW50IGluc3RhbmNlIGZvciBlYWNoIGVsZW1lbnRzIHdpdGhcclxuICAgKiBgZGF0YS1zY3JvbGxgIGF0dHJpYnV0ZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50W119ICRzY3JvbGxFbGVtZW50cyAtIExpc3Qgb2YgZWxlbWVudHMgdGhhdCBuZWVkXHJcbiAgICogICAgIHRvIGJlIHJlZ2FyZGVkLlxyXG4gICAqL1xuICBfc3Vic2NyaWJlU2Nyb2xsRWxlbWVudHMoJHNjcm9sbEVsZW1lbnRzLCBmcm9tSW5kZXggPSAwLCB0b09ic2VydmUgPSBmYWxzZSkge1xuICAgIC8vIEZvciBlYWNoIHNjcm9sbCBlbGVtZW50IGNyZWF0ZSBhIFNjcm9sbEVsZW1lbnQgaW5zdGFuY2VcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgJHNjcm9sbEVsZW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgJHNjcm9sbEVsZW1lbnQgPSAkc2Nyb2xsRWxlbWVudHNbaW5kZXhdO1xuICAgICAgY29uc3QgbmVlZFJhZiA9IHRoaXMuX2NoZWNrUmFmTmVlZGVkKCRzY3JvbGxFbGVtZW50KTtcbiAgICAgIGNvbnN0IHNjcm9sbEVsZW1lbnRJbnN0YW5jZSA9IG5ldyBTY3JvbGxFbGVtZW50KHtcbiAgICAgICAgJGVsOiAkc2Nyb2xsRWxlbWVudCxcbiAgICAgICAgaWQ6IGZyb21JbmRleCArIGluZGV4LFxuICAgICAgICBzY3JvbGxPcmllbnRhdGlvbjogdGhpcy5zY3JvbGxPcmllbnRhdGlvbixcbiAgICAgICAgbW9kdWxhckluc3RhbmNlOiB0aGlzLm1vZHVsYXJJbnN0YW5jZSxcbiAgICAgICAgc3Vic2NyaWJlRWxlbWVudFVwZGF0ZUZuOiB0aGlzLl9zdWJzY3JpYmVFbGVtZW50VXBkYXRlLmJpbmQodGhpcyksXG4gICAgICAgIHVuc3Vic2NyaWJlRWxlbWVudFVwZGF0ZUZuOiB0aGlzLl91bnN1YnNjcmliZUVsZW1lbnRVcGRhdGUuYmluZCh0aGlzKSxcbiAgICAgICAgbmVlZFJhZlxuICAgICAgfSk7XG4gICAgICAvLyBQdXNoIHRvIGNvbW1vbiBhcnJheVxuICAgICAgdGhpcy5zY3JvbGxFbGVtZW50cy5wdXNoKHNjcm9sbEVsZW1lbnRJbnN0YW5jZSk7XG4gICAgICAvLyBQdXNoIHRvIHNwZWNpZmljIGFycmF5XG4gICAgICBpZiAobmVlZFJhZikge1xuICAgICAgICB0aGlzLlJBRlNjcm9sbEVsZW1lbnRzLnB1c2goc2Nyb2xsRWxlbWVudEluc3RhbmNlKTtcbiAgICAgICAgLy8gRHluYW1pYyBvYnNlcnZlIGl0ZW1cbiAgICAgICAgaWYgKHRvT2JzZXJ2ZSkge1xuICAgICAgICAgIHRoaXMuSU9SYWZJbnN0YW5jZS5zY3JvbGxFbGVtZW50cy5wdXNoKHNjcm9sbEVsZW1lbnRJbnN0YW5jZSk7XG4gICAgICAgICAgdGhpcy5JT1JhZkluc3RhbmNlLm9ic2VydmUoc2Nyb2xsRWxlbWVudEluc3RhbmNlLiRlbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcmVkU2Nyb2xsRWxlbWVudHMucHVzaChzY3JvbGxFbGVtZW50SW5zdGFuY2UpO1xuICAgICAgICAvLyBEeW5hbWljIG9ic2VydmUgaXRlbVxuICAgICAgICBpZiAodG9PYnNlcnZlKSB7XG4gICAgICAgICAgdGhpcy5JT1RyaWdnZXJJbnN0YW5jZS5zY3JvbGxFbGVtZW50cy5wdXNoKHNjcm9sbEVsZW1lbnRJbnN0YW5jZSk7XG4gICAgICAgICAgdGhpcy5JT1RyaWdnZXJJbnN0YW5jZS5vYnNlcnZlKHNjcm9sbEVsZW1lbnRJbnN0YW5jZS4kZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENsZWFyIGFsbCBTY3JvbGxFbGVtZW50IGFycmF5cy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIF91bnN1YnNjcmliZUFsbFNjcm9sbEVsZW1lbnRzKCkge1xuICAgIHRoaXMuc2Nyb2xsRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLlJBRlNjcm9sbEVsZW1lbnRzID0gW107XG4gICAgdGhpcy50cmlnZ2VyZWRTY3JvbGxFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuc2Nyb2xsRWxlbWVudHNUb1VwZGF0ZSA9IFtdO1xuICB9XG4gIC8qKlxyXG4gICAqIFN1YnNjcmliZSBTY3JvbGxFbGVtZW50IGluc3RhbmNlIHRoYXQgbmVlZHMgdG8gYmUgdXBkYXRlZC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1Njcm9sbEVsZW1lbnR9IHNjcm9sbEVsZW1lbnQgLSBTY3JvbGxFbGVtZW50IGluc3RhbmNlIGludmlld1xyXG4gICAqICAgICB0aGF0IG5lZWRzIHRvIGJlIHVwZGF0ZWQuXHJcbiAgICovXG4gIF9zdWJzY3JpYmVFbGVtZW50VXBkYXRlKHNjcm9sbEVsZW1lbnQpIHtcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnRzVG9VcGRhdGUucHVzaChzY3JvbGxFbGVtZW50KTtcbiAgfVxuICAvKipcclxuICAgKiBVbnNjcmliZSBTY3JvbGxFbGVtZW50IGluc3RhbmNlIHRoYXQgZG9lc24ndCBuZWVkIHRvIGJlIHVwZGF0ZWQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTY3JvbGxFbGVtZW50fSBzY3JvbGxFbGVtZW50IC0gVGhlIHVwZGF0ZWQgU2Nyb2xsRWxlbWVudCBpbnN0YW5jZVxyXG4gICAqICAgICBvdXQgb2YgdmlldyBub3cuXHJcbiAgICovXG4gIF91bnN1YnNjcmliZUVsZW1lbnRVcGRhdGUoc2Nyb2xsRWxlbWVudCkge1xuICAgIHRoaXMuc2Nyb2xsRWxlbWVudHNUb1VwZGF0ZSA9IHRoaXMuc2Nyb2xsRWxlbWVudHNUb1VwZGF0ZS5maWx0ZXIoc2Nyb2xsRWxlbWVudFRvVXBkYXRlID0+IHNjcm9sbEVsZW1lbnRUb1VwZGF0ZS5pZCAhPSBzY3JvbGxFbGVtZW50LmlkKTtcbiAgfVxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIERPTSBFbGVtZW50IG5lZWQgYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdG8gYmUgdXNlZC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAkc2Nyb2xsRWxlbWVudCAtIFRoZSBlbGVtZW50IHRoYXQgbmVlZHMgdG8gYmUgY2hlY2tlZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xuICBfY2hlY2tSYWZOZWVkZWQoJHNjcm9sbEVsZW1lbnQpIHtcbiAgICBsZXQgYXR0cmlidXRlc1RoYXROZWVkUmFmID0gWy4uLkFUVFJJQlVURVNfVEhBVF9ORUVEX1JBRl07XG4gICAgLy8gUmVtb3ZlIHV0aWxzXG4gICAgY29uc3QgcmVtb3ZlQXR0cmlidXRlID0gYXR0cmlidXRlVG9SZW1vdmUgPT4ge1xuICAgICAgYXR0cmlidXRlc1RoYXROZWVkUmFmID0gYXR0cmlidXRlc1RoYXROZWVkUmFmLmZpbHRlcihhdHRyaWJ1dGUgPT4gYXR0cmlidXRlICE9IGF0dHJpYnV0ZVRvUmVtb3ZlKTtcbiAgICB9O1xuICAgIC8vIDEuIENoZWNrIHNjcm9sbCBvZmZzZXQgdmFsdWVzXG4gICAgaWYgKCRzY3JvbGxFbGVtZW50LmRhdGFzZXQuc2Nyb2xsT2Zmc2V0KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9ICRzY3JvbGxFbGVtZW50LmRhdGFzZXQuc2Nyb2xsT2Zmc2V0LnNwbGl0KCcsJykubWFwKHRlc3QgPT4gdGVzdC5yZXBsYWNlKCclJywgJycpLnRyaW0oKSkuam9pbignLCcpO1xuICAgICAgaWYgKHZhbHVlICE9ICcwLDAnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQXR0cmlidXRlKCdzY3JvbGxPZmZzZXQnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlQXR0cmlidXRlKCdzY3JvbGxPZmZzZXQnKTtcbiAgICB9XG4gICAgLy8gMi4gQ2hlY2sgc2Nyb2xsIHBvc2l0aW9uIHZhbHVlc1xuICAgIGlmICgkc2Nyb2xsRWxlbWVudC5kYXRhc2V0LnNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9ICRzY3JvbGxFbGVtZW50LmRhdGFzZXQuc2Nyb2xsUG9zaXRpb24udHJpbSgpO1xuICAgICAgaWYgKHZhbHVlICE9ICd0b3AsYm90dG9tJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUF0dHJpYnV0ZSgnc2Nyb2xsUG9zaXRpb24nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlQXR0cmlidXRlKCdzY3JvbGxQb3NpdGlvbicpO1xuICAgIH1cbiAgICAvLyAzLiBDaGVjayBzY3JvbGwgc3BlZWQgdmFsdWVzXG4gICAgaWYgKCRzY3JvbGxFbGVtZW50LmRhdGFzZXQuc2Nyb2xsU3BlZWQgJiYgIWlzTmFOKHBhcnNlRmxvYXQoJHNjcm9sbEVsZW1lbnQuZGF0YXNldC5zY3JvbGxTcGVlZCkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlQXR0cmlidXRlKCdzY3JvbGxTcGVlZCcpO1xuICAgIH1cbiAgICAvLyA0LiBDaGVjayBvdGhlcnMgYXR0cmlidXRlc1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZXNUaGF0TmVlZFJhZikge1xuICAgICAgaWYgKGF0dHJpYnV0ZSBpbiAkc2Nyb2xsRWxlbWVudC5kYXRhc2V0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXHJcbiAqIFJlc2l6ZSBPYnNlcnZlclxyXG4gKlxyXG4gKiBUaGUgUmVzaXplIE9ic2VydmVyIEFQSSBwcm92aWRlcyBhIHBlcmZvcm1hbnQgbWVjaGFuaXNtIGJ5IHdoaWNoIGNvZGUgY2FuIG1vbml0b3IgYW4gZWxlbWVudCBmb3IgY2hhbmdlcyB0byBpdHMgc2l6ZSxcclxuICogd2l0aCBub3RpZmljYXRpb25zIGJlaW5nIGRlbGl2ZXJlZCB0byB0aGUgb2JzZXJ2ZXIgZWFjaCB0aW1lIHRoZSBzaXplIGNoYW5nZXMuXHJcbiAqXHJcbiAqIEZlYXR1cmVzIGZ1bmN0aW9ucyB0bzpcclxuICpcclxuICogLSBUcmlnZ2VyIHRoZSByZXNpemUgY2FsbGJhY2sgaWYgdGhlIHNwZWNpZmllZCBlbGVtZW50J3Mgc2l6ZSBjaGFuZ2UuXHJcbiAqXHJcbiAqIFJlZmVyZW5jZXM6XHJcbiAqXHJcbiAqIC0ge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SZXNpemVfT2JzZXJ2ZXJfQVBJfVxyXG4gKi9cbmNsYXNzIFJPIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHJlc2l6ZUVsZW1lbnRzLFxuICAgIHJlc2l6ZUNhbGxiYWNrID0gKCkgPT4ge31cbiAgfSkge1xuICAgIHRoaXMuJHJlc2l6ZUVsZW1lbnRzID0gdm9pZCAwO1xuICAgIHRoaXMuaXNGaXJzdE9ic2VydmUgPSB2b2lkIDA7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLnJlc2l6ZUNhbGxiYWNrID0gdm9pZCAwO1xuICAgIC8vIFBhcmFtZXRlcnNcbiAgICB0aGlzLiRyZXNpemVFbGVtZW50cyA9IHJlc2l6ZUVsZW1lbnRzO1xuICAgIHRoaXMucmVzaXplQ2FsbGJhY2sgPSByZXNpemVDYWxsYmFjaztcbiAgICAvLyBGbGFnc1xuICAgIHRoaXMuaXNGaXJzdE9ic2VydmUgPSB0cnVlO1xuICAgIC8vIEluaXRcbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogTGlmZWN5bGUgLSBJbml0aWFsaXplIFJlc2l6ZSBPYnNlcnZlci5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIF9pbml0KCkge1xuICAgIC8vIENhbGxiYWNrXG4gICAgY29uc3Qgb25SZXNpemUgPSBlbnRyaWVzID0+IHtcbiAgICAgIHZhciBfdGhpcyRyZXNpemVDYWxsYmFjaztcbiAgICAgICF0aGlzLmlzRmlyc3RPYnNlcnZlICYmICgoX3RoaXMkcmVzaXplQ2FsbGJhY2sgPSB0aGlzLnJlc2l6ZUNhbGxiYWNrKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcmVzaXplQ2FsbGJhY2suY2FsbCh0aGlzKSk7XG4gICAgICB0aGlzLmlzRmlyc3RPYnNlcnZlID0gZmFsc2U7XG4gICAgfTtcbiAgICAvLyBJbnN0YW5jZVxuICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIob25SZXNpemUpO1xuICAgIC8vIE9ic2VydmUgZWFjaCBkZWZhdWx0IGVsZW1lbnRzXG4gICAgZm9yIChjb25zdCAkcmVzaXplRWxlbWVudCBvZiB0aGlzLiRyZXNpemVFbGVtZW50cykge1xuICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKCRyZXNpemVFbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogTGlmZWN5bGUgLSBEZXN0cm95IFJlc2l6ZSBPYnNlcnZlci5cclxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxufVxuXG4vKipcclxuICogQHR5cGUge0lMZW5pc09wdGlvbnN9XHJcbiAqL1xuY29uc3QgZGVmYXVsdExlbmlzT3B0aW9ucyA9IHtcbiAgd3JhcHBlcjogd2luZG93LFxuICBjb250ZW50OiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gIGxlcnA6IDAuMSxcbiAgZHVyYXRpb246IDEuMixcbiAgb3JpZW50YXRpb246ICd2ZXJ0aWNhbCcsXG4gIGdlc3R1cmVPcmllbnRhdGlvbjogJ3ZlcnRpY2FsJyxcbiAgc21vb3RoV2hlZWw6IHRydWUsXG4gIHNtb290aFRvdWNoOiBmYWxzZSxcbiAgd2hlZWxNdWx0aXBsaWVyOiAxLFxuICB0b3VjaE11bHRpcGxpZXI6IDIsXG4gIG5vcm1hbGl6ZVdoZWVsOiB0cnVlLFxuICBlYXNpbmc6IHQgPT4gTWF0aC5taW4oMSwgMS4wMDEgLSBNYXRoLnBvdygyLCAtMTAgKiB0KSkgLy8gaHR0cHM6Ly93d3cuZGVzbW9zLmNvbS9jYWxjdWxhdG9yL2JyczU0bDR4b3Vcbn07XG4vKipcclxuICogTG9jb21vdGl2ZSBTY3JvbGxcclxuICpcclxuICogRGV0ZWN0aW9uIG9mIGVsZW1lbnRzIGluIHZpZXdwb3J0ICYgc21vb3RoIHNjcm9sbGluZyB3aXRoIHBhcmFsbGF4LlxyXG4gKlxyXG4gKiBJbnNwaXJlZCBieVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2xvY29tb3RpdmVtdGwvbG9jb21vdGl2ZS1zY3JvbGwgbG9jb21vdGl2ZS1zY3JvbGwuanN9XHJcbiAqIGFuZCBidWlsdCBhcm91bmRcclxuICoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zdHVkaW8tZnJlaWdodC9sZW5pcyBsZW5pcy5qc30uXHJcbiAqL1xuY2xhc3MgTG9jb21vdGl2ZVNjcm9sbCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBsZW5pc09wdGlvbnMgPSB7fSxcbiAgICBtb2R1bGFySW5zdGFuY2UsXG4gICAgdHJpZ2dlclJvb3RNYXJnaW4sXG4gICAgcmFmUm9vdE1hcmdpbixcbiAgICBhdXRvUmVzaXplID0gdHJ1ZSxcbiAgICBhdXRvU3RhcnQgPSB0cnVlLFxuICAgIHNjcm9sbENhbGxiYWNrID0gKCkgPT4ge30sXG4gICAgaW5pdEN1c3RvbVRpY2tlcixcbiAgICBkZXN0cm95Q3VzdG9tVGlja2VyXG4gIH0gPSB7fSkge1xuICAgIHRoaXMucmFmUGxheWluZyA9IHZvaWQgMDtcbiAgICB0aGlzLmxlbmlzSW5zdGFuY2UgPSB2b2lkIDA7XG4gICAgdGhpcy5jb3JlSW5zdGFuY2UgPSB2b2lkIDA7XG4gICAgdGhpcy5sZW5pc09wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5tb2R1bGFySW5zdGFuY2UgPSB2b2lkIDA7XG4gICAgdGhpcy50cmlnZ2VyUm9vdE1hcmdpbiA9IHZvaWQgMDtcbiAgICB0aGlzLnJhZlJvb3RNYXJnaW4gPSB2b2lkIDA7XG4gICAgdGhpcy5yYWZJbnN0YW5jZSA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dG9SZXNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRvU3RhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5ST0luc3RhbmNlID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdEN1c3RvbVRpY2tlciA9IHZvaWQgMDtcbiAgICB0aGlzLmRlc3Ryb3lDdXN0b21UaWNrZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5fb25SZW5kZXJCaW5kID0gdm9pZCAwO1xuICAgIHRoaXMuX29uUmVzaXplQmluZCA9IHZvaWQgMDtcbiAgICB0aGlzLl9vblNjcm9sbFRvQmluZCA9IHZvaWQgMDtcbiAgICAvLyBBcmd1bWVudHNcbiAgICB0aGlzLmxlbmlzT3B0aW9ucyA9IF9leHRlbmRzKHt9LCBkZWZhdWx0TGVuaXNPcHRpb25zLCBsZW5pc09wdGlvbnMpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgbGVuaXNPcHRpb25zLFxuICAgICAgbW9kdWxhckluc3RhbmNlLFxuICAgICAgdHJpZ2dlclJvb3RNYXJnaW4sXG4gICAgICByYWZSb290TWFyZ2luLFxuICAgICAgYXV0b1Jlc2l6ZSxcbiAgICAgIGF1dG9TdGFydCxcbiAgICAgIHNjcm9sbENhbGxiYWNrLFxuICAgICAgaW5pdEN1c3RvbVRpY2tlcixcbiAgICAgIGRlc3Ryb3lDdXN0b21UaWNrZXJcbiAgICB9KTtcbiAgICAvLyBCaW5kaW5nXG4gICAgdGhpcy5fb25SZW5kZXJCaW5kID0gdGhpcy5fb25SZW5kZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblNjcm9sbFRvQmluZCA9IHRoaXMuX29uU2Nyb2xsVG8uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblJlc2l6ZUJpbmQgPSB0aGlzLl9vblJlc2l6ZS5iaW5kKHRoaXMpO1xuICAgIC8vIERhdGFcbiAgICB0aGlzLnJhZlBsYXlpbmcgPSBmYWxzZTtcbiAgICAvLyBJbml0XG4gICAgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIExpZmVjeWxlIC0gSW5pdGlhbGl6ZSBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIF9pbml0KCkge1xuICAgIHZhciBfdGhpcyRsZW5pc0luc3RhbmNlO1xuICAgIC8vIENyZWF0ZSBMZW5pcyBpbnN0YW5jZVxuICAgIHRoaXMubGVuaXNJbnN0YW5jZSA9IG5ldyBMZW5pcyh7XG4gICAgICB3cmFwcGVyOiB0aGlzLmxlbmlzT3B0aW9ucy53cmFwcGVyLFxuICAgICAgY29udGVudDogdGhpcy5sZW5pc09wdGlvbnMuY29udGVudCxcbiAgICAgIGxlcnA6IHRoaXMubGVuaXNPcHRpb25zLmxlcnAsXG4gICAgICBkdXJhdGlvbjogdGhpcy5sZW5pc09wdGlvbnMuZHVyYXRpb24sXG4gICAgICBvcmllbnRhdGlvbjogdGhpcy5sZW5pc09wdGlvbnMub3JpZW50YXRpb24sXG4gICAgICBnZXN0dXJlT3JpZW50YXRpb246IHRoaXMubGVuaXNPcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbixcbiAgICAgIHNtb290aFdoZWVsOiB0aGlzLmxlbmlzT3B0aW9ucy5zbW9vdGhXaGVlbCxcbiAgICAgIHNtb290aFRvdWNoOiB0aGlzLmxlbmlzT3B0aW9ucy5zbW9vdGhUb3VjaCxcbiAgICAgIHdoZWVsTXVsdGlwbGllcjogdGhpcy5sZW5pc09wdGlvbnMud2hlZWxNdWx0aXBsaWVyLFxuICAgICAgdG91Y2hNdWx0aXBsaWVyOiB0aGlzLmxlbmlzT3B0aW9ucy50b3VjaE11bHRpcGxpZXIsXG4gICAgICBub3JtYWxpemVXaGVlbDogdGhpcy5sZW5pc09wdGlvbnMubm9ybWFsaXplV2hlZWwsXG4gICAgICBlYXNpbmc6IHRoaXMubGVuaXNPcHRpb25zLmVhc2luZ1xuICAgIH0pO1xuICAgIChfdGhpcyRsZW5pc0luc3RhbmNlID0gdGhpcy5sZW5pc0luc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbGVuaXNJbnN0YW5jZS5vbignc2Nyb2xsJywgdGhpcy5zY3JvbGxDYWxsYmFjayk7XG4gICAgLy8gQWRkIHNjcm9sbCBkaXJlY3Rpb24gYXR0cmlidXRlIG9uIGJvZHlcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXNjcm9sbC1vcmllbnRhdGlvbicsIHRoaXMubGVuaXNJbnN0YW5jZS5vcHRpb25zLm9yaWVudGF0aW9uKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIENvcmUgSW5zdGFuY2VcbiAgICAgIHRoaXMuY29yZUluc3RhbmNlID0gbmV3IENvcmUoe1xuICAgICAgICAkZWw6IHRoaXMubGVuaXNJbnN0YW5jZS5yb290RWxlbWVudCxcbiAgICAgICAgbW9kdWxhckluc3RhbmNlOiB0aGlzLm1vZHVsYXJJbnN0YW5jZSxcbiAgICAgICAgdHJpZ2dlclJvb3RNYXJnaW46IHRoaXMudHJpZ2dlclJvb3RNYXJnaW4sXG4gICAgICAgIHJhZlJvb3RNYXJnaW46IHRoaXMucmFmUm9vdE1hcmdpbixcbiAgICAgICAgc2Nyb2xsT3JpZW50YXRpb246IHRoaXMubGVuaXNJbnN0YW5jZS5vcHRpb25zLm9yaWVudGF0aW9uXG4gICAgICB9KTtcbiAgICAgIC8vIEJpbmQgRXZlbnRzXG4gICAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgICAvLyBSQUYgd2FybmluZ1xuICAgICAgaWYgKHRoaXMuaW5pdEN1c3RvbVRpY2tlciAmJiAhdGhpcy5kZXN0cm95Q3VzdG9tVGlja2VyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignaW5pdEN1c3RvbVRpY2tlciBjYWxsYmFjayBpcyBkZWNsYXJlZCwgYnV0IGRlc3Ryb3lDdXN0b21UaWNrZXIgaXMgbm90LiBQbGVhc2UgcGF5IGF0dGVudGlvbi4gSXQgY291bGQgY2F1c2UgdHJvdWJsZS4nKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaW5pdEN1c3RvbVRpY2tlciAmJiB0aGlzLmRlc3Ryb3lDdXN0b21UaWNrZXIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdkZXN0cm95Q3VzdG9tVGlja2VyIGNhbGxiYWNrIGlzIGRlY2xhcmVkLCBidXQgaW5pdEN1c3RvbVRpY2tlciBpcyBub3QuIFBsZWFzZSBwYXkgYXR0ZW50aW9uLiBJdCBjb3VsZCBjYXVzZSB0cm91YmxlLicpO1xuICAgICAgfVxuICAgICAgLy8gU3RhcnQgUkFGXG4gICAgICB0aGlzLmF1dG9TdGFydCAmJiB0aGlzLnN0YXJ0KCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogTGlmZWN5bGUgLSBEZXN0cm95IGluc3RhbmNlLlxyXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIC8vIFN0b3AgcmFmXG4gICAgdGhpcy5zdG9wKCk7XG4gICAgLy8gVW5iaW5kIEV2ZW50c1xuICAgIHRoaXMuX3VuYmluZEV2ZW50cygpO1xuICAgIC8vIERlc3Ryb3kgTGVuaXNcbiAgICB0aGlzLmxlbmlzSW5zdGFuY2UuZGVzdHJveSgpO1xuICAgIC8vIERlc3Ryb3kgQ29yZVxuICAgIHRoaXMuY29yZUluc3RhbmNlLmRlc3Ryb3koKTtcbiAgfVxuICAvKipcclxuICAgKiBFdmVudHMgLSBTdWJzY3JpYmUgZXZlbnRzIHRvIGxpc3Rlbi5cclxuICAgKi9cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5fYmluZFNjcm9sbFRvRXZlbnRzKCk7XG4gICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSkge1xuICAgICAgaWYgKCdSZXNpemVPYnNlcnZlcicgaW4gd2luZG93KSB7XG4gICAgICAgIHRoaXMuUk9JbnN0YW5jZSA9IG5ldyBSTyh7XG4gICAgICAgICAgcmVzaXplRWxlbWVudHM6IFtkb2N1bWVudC5ib2R5XSxcbiAgICAgICAgICByZXNpemVDYWxsYmFjazogdGhpcy5fb25SZXNpemVCaW5kXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplQmluZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEV2ZW50cyAtIFVuc3Vic2NyaWJlIGxpc3RlbmVkIGV2ZW50cy5cclxuICAgKi9cbiAgX3VuYmluZEV2ZW50cygpIHtcbiAgICB0aGlzLl91bmJpbmRTY3JvbGxUb0V2ZW50cygpO1xuICAgIGlmICh0aGlzLmF1dG9SZXNpemUpIHtcbiAgICAgIGlmICgnUmVzaXplT2JzZXJ2ZXInIGluIHdpbmRvdykge1xuICAgICAgICB0aGlzLlJPSW5zdGFuY2UgJiYgdGhpcy5ST0luc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZUJpbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBFdmVudHMgLSBTdWJzY3JpYmUgc2Nyb2xsVG8gZXZlbnRzIHRvIGxpc3Rlbi5cclxuICAgKi9cbiAgX2JpbmRTY3JvbGxUb0V2ZW50cygkY29udGFpbmVyKSB7XG4gICAgY29uc3QgJHJvb3RDb250YWluZXIgPSAkY29udGFpbmVyID8gJGNvbnRhaW5lciA6IHRoaXMubGVuaXNJbnN0YW5jZS5yb290RWxlbWVudDtcbiAgICBjb25zdCAkc2Nyb2xsVG9FbGVtZW50cyA9ICRyb290Q29udGFpbmVyID09IG51bGwgPyB2b2lkIDAgOiAkcm9vdENvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zY3JvbGwtdG9dJyk7XG4gICAgKCRzY3JvbGxUb0VsZW1lbnRzID09IG51bGwgPyB2b2lkIDAgOiAkc2Nyb2xsVG9FbGVtZW50cy5sZW5ndGgpICYmICRzY3JvbGxUb0VsZW1lbnRzLmZvckVhY2goJGVsID0+IHtcbiAgICAgICRlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uU2Nyb2xsVG9CaW5kLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogRXZlbnRzIC0gVW5zdWJzY3JpYmUgc2Nyb2xsVG8gbGlzdGVuZWQgZXZlbnRzLlxyXG4gICAqL1xuICBfdW5iaW5kU2Nyb2xsVG9FdmVudHMoJGNvbnRhaW5lcikge1xuICAgIGNvbnN0ICRyb290Q29udGFpbmVyID0gJGNvbnRhaW5lciA/ICRjb250YWluZXIgOiB0aGlzLmxlbmlzSW5zdGFuY2Uucm9vdEVsZW1lbnQ7XG4gICAgY29uc3QgJHNjcm9sbFRvRWxlbWVudHMgPSAkcm9vdENvbnRhaW5lciA9PSBudWxsID8gdm9pZCAwIDogJHJvb3RDb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2Nyb2xsLXRvXScpO1xuICAgICgkc2Nyb2xsVG9FbGVtZW50cyA9PSBudWxsID8gdm9pZCAwIDogJHNjcm9sbFRvRWxlbWVudHMubGVuZ3RoKSAmJiAkc2Nyb2xsVG9FbGVtZW50cy5mb3JFYWNoKCRlbCA9PiB7XG4gICAgICAkZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vblNjcm9sbFRvQmluZCwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIC0gUmVzaXplIGNhbGxiYWNrLlxyXG4gICAqL1xuICBfb25SZXNpemUoKSB7XG4gICAgLy8gV2FpdGluZyB0aGUgbmV4dCBmcmFtZSB0byBnZXQgdGhlIG5ldyBjdXJyZW50IHNjcm9sbCB2YWx1ZSByZXR1cm4gYnkgTGVuaXNcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdmFyIF90aGlzJGNvcmVJbnN0YW5jZTtcbiAgICAgIChfdGhpcyRjb3JlSW5zdGFuY2UgPSB0aGlzLmNvcmVJbnN0YW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNvcmVJbnN0YW5jZS5vblJlc2l6ZSh7XG4gICAgICAgIGN1cnJlbnRTY3JvbGw6IHRoaXMubGVuaXNJbnN0YW5jZS5zY3JvbGxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIC0gUmVuZGVyIGNhbGxiYWNrLlxyXG4gICAqL1xuICBfb25SZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJGxlbmlzSW5zdGFuY2UyLCBfdGhpcyRjb3JlSW5zdGFuY2UyO1xuICAgIChfdGhpcyRsZW5pc0luc3RhbmNlMiA9IHRoaXMubGVuaXNJbnN0YW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGxlbmlzSW5zdGFuY2UyLnJhZihEYXRlLm5vdygpKTtcbiAgICAoX3RoaXMkY29yZUluc3RhbmNlMiA9IHRoaXMuY29yZUluc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkY29yZUluc3RhbmNlMi5vblJlbmRlcih7XG4gICAgICBjdXJyZW50U2Nyb2xsOiB0aGlzLmxlbmlzSW5zdGFuY2Uuc2Nyb2xsLFxuICAgICAgc21vb3RoOiB0aGlzLmxlbmlzSW5zdGFuY2UuaXNTbW9vdGhcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBDYWxsYmFjayAtIFNjcm9sbCBUbyBjYWxsYmFjay5cclxuICAgKi9cbiAgX29uU2Nyb2xsVG8oZXZlbnQpIHtcbiAgICB2YXIgX2V2ZW50JGN1cnJlbnRUYXJnZXQ7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCAkdGFyZ2V0ID0gKF9ldmVudCRjdXJyZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCkgIT0gbnVsbCA/IF9ldmVudCRjdXJyZW50VGFyZ2V0IDogbnVsbDtcbiAgICBpZiAoISR0YXJnZXQpIHJldHVybjtcbiAgICBjb25zdCB0YXJnZXQgPSAkdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1zY3JvbGwtdG8taHJlZicpIHx8ICR0YXJnZXQuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gJHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2Nyb2xsLXRvLW9mZnNldCcpIHx8IDA7XG4gICAgY29uc3QgZHVyYXRpb24gPSAkdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1zY3JvbGwtdG8tZHVyYXRpb24nKSB8fCB0aGlzLmxlbmlzT3B0aW9ucy5kdXJhdGlvbiB8fCBkZWZhdWx0TGVuaXNPcHRpb25zLmR1cmF0aW9uO1xuICAgIHRhcmdldCAmJiB0aGlzLnNjcm9sbFRvKHRhcmdldCwge1xuICAgICAgb2Zmc2V0OiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJyA/IHBhcnNlSW50KG9mZnNldCkgOiBvZmZzZXQsXG4gICAgICBkdXJhdGlvbjogdHlwZW9mIGR1cmF0aW9uID09PSAnc3RyaW5nJyA/IHBhcnNlSW50KGR1cmF0aW9uKSA6IGR1cmF0aW9uXG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogU3RhcnQgUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRoYXQgYWN0aXZlIExlbmlzIHNtb290aCBhbmQgc2Nyb2xsIHByb2dyZXNzLlxyXG4gICAqL1xuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5yYWZQbGF5aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmFmUGxheWluZyA9IHRydWU7XG4gICAgdGhpcy5pbml0Q3VzdG9tVGlja2VyID8gdGhpcy5pbml0Q3VzdG9tVGlja2VyKHRoaXMuX29uUmVuZGVyQmluZCkgOiB0aGlzLl9yYWYoKTtcbiAgfVxuICAvKipcclxuICAgKiBTdG9wIFJlcXVlc3RBbmltYXRpb25GcmFtZSB0aGF0IGFjdGl2ZSBMZW5pcyBzbW9vdGggYW5kIHNjcm9sbCBwcm9ncmVzcy5cclxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICBpZiAoIXRoaXMucmFmUGxheWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJhZlBsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRlc3Ryb3lDdXN0b21UaWNrZXIgPyB0aGlzLmRlc3Ryb3lDdXN0b21UaWNrZXIodGhpcy5fb25SZW5kZXJCaW5kKSA6IHRoaXMucmFmSW5zdGFuY2UgJiYgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWZJbnN0YW5jZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVtb3ZlIG9sZCBzY3JvbGwgZWxlbWVudHMgaXRlbXMgYW5kIHJlYnVpbGQgU2Nyb2xsRWxlbWVudHMgaW5zdGFuY2VzLlxyXG4gICAqL1xuICByZW1vdmVTY3JvbGxFbGVtZW50cygkb2xkQ29udGFpbmVyKSB7XG4gICAgdmFyIF90aGlzJGNvcmVJbnN0YW5jZTM7XG4gICAgaWYgKCEkb2xkQ29udGFpbmVyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdQbGVhc2UgcHJvdmlkZSBhIERPTSBFbGVtZW50IGFzICRvbGRDb250YWluZXInKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdW5iaW5kU2Nyb2xsVG9FdmVudHMoJG9sZENvbnRhaW5lcik7XG4gICAgKF90aGlzJGNvcmVJbnN0YW5jZTMgPSB0aGlzLmNvcmVJbnN0YW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNvcmVJbnN0YW5jZTMucmVtb3ZlU2Nyb2xsRWxlbWVudHMoJG9sZENvbnRhaW5lcik7XG4gIH1cbiAgLyoqXHJcbiAgICogQWRkIG5ldyBzY3JvbGwgZWxlbWVudHMgaXRlbXMgYW5kIHJlYnVpbGQgU2Nyb2xsRWxlbWVudHMgaW5zdGFuY2VzLlxyXG4gICAqL1xuICBhZGRTY3JvbGxFbGVtZW50cygkbmV3Q29udGFpbmVyKSB7XG4gICAgdmFyIF90aGlzJGNvcmVJbnN0YW5jZTQ7XG4gICAgaWYgKCEkbmV3Q29udGFpbmVyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdQbGVhc2UgcHJvdmlkZSBhIERPTSBFbGVtZW50IGFzICRuZXdDb250YWluZXInKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKF90aGlzJGNvcmVJbnN0YW5jZTQgPSB0aGlzLmNvcmVJbnN0YW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNvcmVJbnN0YW5jZTQuYWRkU2Nyb2xsRWxlbWVudHMoJG5ld0NvbnRhaW5lcik7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuX2JpbmRTY3JvbGxUb0V2ZW50cygkbmV3Q29udGFpbmVyKTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBUcmlnZ2VyIHJlc2l6ZSBjYWxsYmFjay5cclxuICAgKi9cbiAgcmVzaXplKCkge1xuICAgIHRoaXMuX29uUmVzaXplQmluZCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFRyaWdnZXIgc2Nyb2xsIHRvIGNhbGxiYWNrLlxyXG4gICAqL1xuICBzY3JvbGxUbyh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMkbGVuaXNJbnN0YW5jZTM7XG4gICAgKF90aGlzJGxlbmlzSW5zdGFuY2UzID0gdGhpcy5sZW5pc0luc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbGVuaXNJbnN0YW5jZTMuc2Nyb2xsVG8odGFyZ2V0LCB7XG4gICAgICBvZmZzZXQ6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgbGVycDogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5sZXJwLFxuICAgICAgZHVyYXRpb246IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZHVyYXRpb24sXG4gICAgICBpbW1lZGlhdGU6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaW1tZWRpYXRlLFxuICAgICAgbG9jazogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5sb2NrLFxuICAgICAgZm9yY2U6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZm9yY2UsXG4gICAgICBlYXNpbmc6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZWFzaW5nLFxuICAgICAgb25Db21wbGV0ZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5vbkNvbXBsZXRlXG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRoYXQgYWN0aXZlIExlbmlzIHNtb290aCBhbmQgc2Nyb2xsIHByb2dyZXNzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqL1xuICBfcmFmKCkge1xuICAgIHRoaXMuX29uUmVuZGVyQmluZCgpO1xuICAgIHRoaXMucmFmSW5zdGFuY2UgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5fcmFmKCkpO1xuICB9XG59XG5cbmV4cG9ydCB7IExvY29tb3RpdmVTY3JvbGwgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jb21vdGl2ZS1zY3JvbGwubW9kZXJuLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/locomotive-scroll/dist/locomotive-scroll.modern.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/locomotive-scroll/node_modules/@studio-freight/lenis/dist/lenis.modern.mjs":
/*!*************************************************************************************************!*\
  !*** ./node_modules/locomotive-scroll/node_modules/@studio-freight/lenis/dist/lenis.modern.mjs ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ l)\n/* harmony export */ });\nfunction t(){return t=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var i=arguments[e];for(var s in i)Object.prototype.hasOwnProperty.call(i,s)&&(t[s]=i[s])}return t},t.apply(this,arguments)}function e(t,e,i){return Math.max(t,Math.min(e,i))}class i{advance(t){var i;if(!this.isRunning)return;let s=!1;if(this.lerp)this.value=(1-(o=this.lerp))*this.value+o*this.to,Math.round(this.value)===this.to&&(this.value=this.to,s=!0);else{this.currentTime+=t;const i=e(0,this.currentTime/this.duration,1);s=i>=1;const o=s?1:this.easing(i);this.value=this.from+(this.to-this.from)*o}var o;null==(i=this.onUpdate)||i.call(this,this.value,{completed:s}),s&&this.stop()}stop(){this.isRunning=!1}fromTo(t,e,{lerp:i=.1,duration:s=1,easing:o=(t=>t),onUpdate:n}){this.from=this.value=t,this.to=e,this.lerp=i,this.duration=s,this.easing=o,this.currentTime=0,this.isRunning=!0,this.onUpdate=n}}function s(t,e){let i;return function(){let s=arguments,o=this;clearTimeout(i),i=setTimeout(function(){t.apply(o,s)},e)}}class o{constructor(t,e){this.onWindowResize=()=>{this.width=window.innerWidth,this.height=window.innerHeight},this.onWrapperResize=()=>{this.width=this.wrapper.clientWidth,this.height=this.wrapper.clientHeight},this.onContentResize=()=>{const t=this.wrapper===window?document.documentElement:this.wrapper;this.scrollHeight=t.scrollHeight,this.scrollWidth=t.scrollWidth},this.wrapper=t,this.content=e,this.wrapper===window?(window.addEventListener(\"resize\",this.onWindowResize,!1),this.onWindowResize()):(this.wrapperResizeObserver=new ResizeObserver(s(this.onWrapperResize,100)),this.wrapperResizeObserver.observe(this.wrapper),this.onWrapperResize()),this.contentResizeObserver=new ResizeObserver(s(this.onContentResize,100)),this.contentResizeObserver.observe(this.content),this.onContentResize()}destroy(){var t,e;window.removeEventListener(\"resize\",this.onWindowResize,!1),null==(t=this.wrapperResizeObserver)||t.disconnect(),null==(e=this.contentResizeObserver)||e.disconnect()}get limit(){return{x:this.scrollWidth-this.width,y:this.scrollHeight-this.height}}}let n=()=>({events:{},emit(t,...e){let i=this.events[t]||[];for(let t=0,s=i.length;t<s;t++)i[t](...e)},on(t,e){var i;return(null==(i=this.events[t])?void 0:i.push(e))||(this.events[t]=[e]),()=>{var i;this.events[t]=null==(i=this.events[t])?void 0:i.filter(t=>e!==t)}}});class r{constructor(t,{wheelMultiplier:i=1,touchMultiplier:s=2,normalizeWheel:o=!1}){this.onTouchStart=t=>{const{clientX:e,clientY:i}=t.targetTouches?t.targetTouches[0]:t;this.touchStart.x=e,this.touchStart.y=i,this.lastDelta={x:0,y:0}},this.onTouchMove=t=>{const{clientX:e,clientY:i}=t.targetTouches?t.targetTouches[0]:t,s=-(e-this.touchStart.x)*this.touchMultiplier,o=-(i-this.touchStart.y)*this.touchMultiplier;this.touchStart.x=e,this.touchStart.y=i,this.lastDelta={x:s,y:o},this.emitter.emit(\"scroll\",{type:\"touch\",deltaX:s,deltaY:o,event:t})},this.onTouchEnd=t=>{this.emitter.emit(\"scroll\",{type:\"touch\",inertia:!0,deltaX:this.lastDelta.x,deltaY:this.lastDelta.y,event:t})},this.onWheel=t=>{let{deltaX:i,deltaY:s}=t;this.normalizeWheel&&(i=e(-100,i,100),s=e(-100,s,100)),i*=this.wheelMultiplier,s*=this.wheelMultiplier,this.emitter.emit(\"scroll\",{type:\"wheel\",deltaX:i,deltaY:s,event:t})},this.element=t,this.wheelMultiplier=i,this.touchMultiplier=s,this.normalizeWheel=o,this.touchStart={x:null,y:null},this.emitter=n(),this.element.addEventListener(\"wheel\",this.onWheel,{passive:!1}),this.element.addEventListener(\"touchstart\",this.onTouchStart,{passive:!1}),this.element.addEventListener(\"touchmove\",this.onTouchMove,{passive:!1}),this.element.addEventListener(\"touchend\",this.onTouchEnd,{passive:!1})}on(t,e){return this.emitter.on(t,e)}destroy(){this.emitter.events={},this.element.removeEventListener(\"wheel\",this.onWheel,{passive:!1}),this.element.removeEventListener(\"touchstart\",this.onTouchStart,{passive:!1}),this.element.removeEventListener(\"touchmove\",this.onTouchMove,{passive:!1}),this.element.removeEventListener(\"touchend\",this.onTouchEnd,{passive:!1})}}class l{constructor({direction:e,gestureDirection:s,mouseMultiplier:l,smooth:h,wrapper:a=window,content:c=document.documentElement,wheelEventsTarget:u=a,smoothWheel:p=null==h||h,smoothTouch:d=!1,syncTouch:m=!1,syncTouchLerp:v=.1,touchInertiaMultiplier:g=35,duration:S,easing:w=(t=>Math.min(1,1.001-Math.pow(2,-10*t))),lerp:f=(S?null:.1),infinite:y=!1,orientation:T=(null!=e?e:\"vertical\"),gestureOrientation:z=(null!=s?s:\"vertical\"),touchMultiplier:M=1,wheelMultiplier:E=(null!=l?l:1),normalizeWheel:L=!1}={}){this.onVirtualScroll=({type:e,inertia:i,deltaX:s,deltaY:o,event:n})=>{if(n.ctrlKey)return;const r=\"touch\"===e,l=\"wheel\"===e;if(\"vertical\"===this.options.gestureOrientation&&0===o||\"horizontal\"===this.options.gestureOrientation&&0===s||r&&\"vertical\"===this.options.gestureOrientation&&0===this.scroll&&!this.options.infinite&&o<=0)return;if(n.composedPath().find(t=>null==t||null==t.hasAttribute?void 0:t.hasAttribute(\"data-lenis-prevent\")))return;if(this.isStopped||this.isLocked)return void n.preventDefault();if(this.isSmooth=(this.options.smoothTouch||this.options.syncTouch)&&r||this.options.smoothWheel&&l,!this.isSmooth)return this.isScrolling=!1,void this.animate.stop();n.preventDefault();let h=o;\"both\"===this.options.gestureOrientation?h=Math.abs(o)>Math.abs(s)?o:s:\"horizontal\"===this.options.gestureOrientation&&(h=s);const a=r&&this.options.syncTouch,c=r&&i&&Math.abs(h)>1;c&&(h=this.velocity*this.options.touchInertiaMultiplier),this.scrollTo(this.targetScroll+h,t({programmatic:!1},a&&{lerp:c?this.syncTouchLerp:.4}))},this.onScroll=()=>{if(!this.isScrolling){const t=this.animatedScroll;this.animatedScroll=this.targetScroll=this.actualScroll,this.velocity=0,this.direction=Math.sign(this.animatedScroll-t),this.emit()}},e&&console.warn(\"Lenis: `direction` option is deprecated, use `orientation` instead\"),s&&console.warn(\"Lenis: `gestureDirection` option is deprecated, use `gestureOrientation` instead\"),l&&console.warn(\"Lenis: `mouseMultiplier` option is deprecated, use `wheelMultiplier` instead\"),h&&console.warn(\"Lenis: `smooth` option is deprecated, use `smoothWheel` instead\"),window.lenisVersion=\"1.0.11\",a!==document.documentElement&&a!==document.body||(a=window),this.options={wrapper:a,content:c,wheelEventsTarget:u,smoothWheel:p,smoothTouch:d,syncTouch:m,syncTouchLerp:v,touchInertiaMultiplier:g,duration:S,easing:w,lerp:f,infinite:y,gestureOrientation:z,orientation:T,touchMultiplier:M,wheelMultiplier:E,normalizeWheel:L},this.dimensions=new o(a,c),this.rootElement.classList.add(\"lenis\"),this.velocity=0,this.isStopped=!1,this.isSmooth=p||d,this.isScrolling=!1,this.targetScroll=this.animatedScroll=this.actualScroll,this.animate=new i,this.emitter=n(),this.options.wrapper.addEventListener(\"scroll\",this.onScroll,{passive:!1}),this.virtualScroll=new r(u,{touchMultiplier:M,wheelMultiplier:E,normalizeWheel:L}),this.virtualScroll.on(\"scroll\",this.onVirtualScroll)}destroy(){this.emitter.events={},this.options.wrapper.removeEventListener(\"scroll\",this.onScroll,{passive:!1}),this.virtualScroll.destroy()}on(t,e){return this.emitter.on(t,e)}off(t,e){var i;this.emitter.events[t]=null==(i=this.emitter.events[t])?void 0:i.filter(t=>e!==t)}setScroll(t){this.isHorizontal?this.rootElement.scrollLeft=t:this.rootElement.scrollTop=t}emit(){this.emitter.emit(\"scroll\",this)}reset(){this.isLocked=!1,this.isScrolling=!1,this.velocity=0,this.animate.stop()}start(){this.isStopped=!1,this.reset()}stop(){this.isStopped=!0,this.animate.stop(),this.reset()}raf(t){const e=t-(this.time||t);this.time=t,this.animate.advance(.001*e)}scrollTo(t,{offset:i=0,immediate:s=!1,lock:o=!1,duration:n=this.options.duration,easing:r=this.options.easing,lerp:l=!n&&this.options.lerp,onComplete:h=null,force:a=!1,programmatic:c=!0}={}){if(!this.isStopped||a){if([\"top\",\"left\",\"start\"].includes(t))t=0;else if([\"bottom\",\"right\",\"end\"].includes(t))t=this.limit;else{var u;let e;if(\"string\"==typeof t?e=document.querySelector(t):null!=(u=t)&&u.nodeType&&(e=t),e){if(this.options.wrapper!==window){const t=this.options.wrapper.getBoundingClientRect();i-=this.isHorizontal?t.left:t.top}const s=e.getBoundingClientRect();t=(this.isHorizontal?s.left:s.top)+this.animatedScroll}}if(\"number\"==typeof t){if(t+=i,t=Math.round(t),this.options.infinite?c&&(this.targetScroll=this.animatedScroll=this.scroll):t=e(0,t,this.limit),s)return this.animatedScroll=this.targetScroll=t,this.setScroll(this.scroll),this.reset(),this.emit(),void(null==h||h());if(!c){if(t===this.targetScroll)return;this.targetScroll=t}this.animate.fromTo(this.animatedScroll,t,{duration:n,easing:r,lerp:l,onUpdate:(t,{completed:e})=>{o&&(this.isLocked=!0),this.isScrolling=!0,this.velocity=t-this.animatedScroll,this.direction=Math.sign(this.velocity),this.animatedScroll=t,this.setScroll(this.scroll),c&&(this.targetScroll=t),e&&(o&&(this.isLocked=!1),requestAnimationFrame(()=>{this.isScrolling=!1}),this.velocity=0,null==h||h()),this.emit()}})}}}get rootElement(){return this.options.wrapper===window?this.options.content:this.options.wrapper}get limit(){return this.isHorizontal?this.dimensions.limit.x:this.dimensions.limit.y}get isHorizontal(){return\"horizontal\"===this.options.orientation}get actualScroll(){return this.isHorizontal?this.rootElement.scrollLeft:this.rootElement.scrollTop}get scroll(){return this.options.infinite?function(t,e){let i=t%e;return(e>0&&i<0||e<0&&i>0)&&(i+=e),i}(this.animatedScroll,this.limit):this.animatedScroll}get progress(){return 0===this.limit?1:this.scroll/this.limit}get isSmooth(){return this.__isSmooth}set isSmooth(t){this.__isSmooth!==t&&(this.rootElement.classList.toggle(\"lenis-smooth\",t),this.__isSmooth=t)}get isScrolling(){return this.__isScrolling}set isScrolling(t){this.__isScrolling!==t&&(this.rootElement.classList.toggle(\"lenis-scrolling\",t),this.__isScrolling=t)}get isStopped(){return this.__isStopped}set isStopped(t){this.__isStopped!==t&&(this.rootElement.classList.toggle(\"lenis-stopped\",t),this.__isStopped=t)}}\n//# sourceMappingURL=lenis.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbG9jb21vdGl2ZS1zY3JvbGwvbm9kZV9tb2R1bGVzL0BzdHVkaW8tZnJlaWdodC9sZW5pcy9kaXN0L2xlbmlzLm1vZGVybi5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGFBQWEsd0RBQXdELFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLHNFQUFzRSxTQUFTLHlCQUF5QixrQkFBa0IsaUNBQWlDLFFBQVEsV0FBVyxNQUFNLDBCQUEwQixTQUFTLDJIQUEySCxLQUFLLG9CQUFvQiw4Q0FBOEMsT0FBTywyQkFBMkIsMkNBQTJDLE1BQU0saURBQWlELFlBQVksaUJBQWlCLE9BQU8sa0JBQWtCLFlBQVksa0RBQWtELEVBQUUsaUlBQWlJLGdCQUFnQixNQUFNLGtCQUFrQix1QkFBdUIsd0NBQXdDLGFBQWEsS0FBSyxRQUFRLGlCQUFpQix5QkFBeUIsNERBQTRELDJCQUEyQiwwRUFBMEUsMkJBQTJCLG9FQUFvRSxnRUFBZ0UsOGFBQThhLFVBQVUsUUFBUSxzS0FBc0ssWUFBWSxPQUFPLGdFQUFnRSxZQUFZLFNBQVMsY0FBYyx5QkFBeUIsdUJBQXVCLElBQUksZUFBZSxTQUFTLE1BQU0sNkVBQTZFLE1BQU0sb0VBQW9FLEVBQUUsUUFBUSxlQUFlLDREQUE0RCxFQUFFLHNCQUFzQixNQUFNLG9CQUFvQixzQ0FBc0Msd0RBQXdELFNBQVMsc0JBQXNCLE1BQU0sb0JBQW9CLGtJQUFrSSx3REFBd0QsUUFBUSw2QkFBNkIsdUNBQXVDLEVBQUUscUJBQXFCLDRCQUE0QixnRkFBZ0YsRUFBRSxrQkFBa0IsSUFBSSxrQkFBa0IsR0FBRyxtSUFBbUksdUNBQXVDLEVBQUUscUdBQXFHLGNBQWMsc0VBQXNFLFdBQVcsZ0VBQWdFLFdBQVcsOERBQThELFdBQVcsNERBQTRELFdBQVcsRUFBRSxRQUFRLDRCQUE0QixVQUFVLHNCQUFzQix3REFBd0QsV0FBVyxtRUFBbUUsV0FBVyxpRUFBaUUsV0FBVywrREFBK0QsV0FBVyxHQUFHLFFBQVEsYUFBYSxtZUFBbWUsR0FBRyxFQUFFLHVCQUF1QiwyQ0FBMkMsSUFBSSxvQkFBb0Isa0NBQWtDLHFOQUFxTiw4R0FBOEcsZ0VBQWdFLHVLQUF1SyxtQkFBbUIsUUFBUSw2SEFBNkgsd0RBQXdELDhGQUE4RixnQkFBZ0IsS0FBSyw2QkFBNkIsR0FBRyxvQkFBb0Isc0JBQXNCLDRCQUE0QixxSUFBcUkscWRBQXFkLHVQQUF1UCx1U0FBdVMsV0FBVyw4QkFBOEIscURBQXFELHVEQUF1RCxVQUFVLHNCQUFzQixrRUFBa0UsV0FBVywrQkFBK0IsUUFBUSw0QkFBNEIsU0FBUyxNQUFNLGtGQUFrRixhQUFhLDZFQUE2RSxPQUFPLGlDQUFpQyxRQUFRLHlFQUF5RSxRQUFRLCtCQUErQixPQUFPLG1EQUFtRCxPQUFPLHlCQUF5Qix5Q0FBeUMsWUFBWSw4S0FBOEssR0FBRyxFQUFFLHVCQUF1QiwwQ0FBMEMsMERBQTBELEtBQUssTUFBTSxNQUFNLG9GQUFvRixrQ0FBa0MscURBQXFELGtDQUFrQyxrQ0FBa0Msd0RBQXdELHVCQUF1QixrUEFBa1AsT0FBTyxnQ0FBZ0Msb0JBQW9CLDJDQUEyQyx3Q0FBd0MsWUFBWSxJQUFJLHNQQUFzUCxvQkFBb0IsNkNBQTZDLElBQUksa0JBQWtCLCtFQUErRSxZQUFZLHlFQUF5RSxtQkFBbUIsOENBQThDLG1CQUFtQixnRkFBZ0YsYUFBYSwyQ0FBMkMsVUFBVSxxQ0FBcUMscURBQXFELGVBQWUsK0NBQStDLGVBQWUsdUJBQXVCLGdCQUFnQiw2RkFBNkYsa0JBQWtCLDBCQUEwQixtQkFBbUIsc0dBQXNHLGdCQUFnQix3QkFBd0IsaUJBQWlCLGlHQUFzSDtBQUNyeVQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvbG9jb21vdGl2ZS1zY3JvbGwvbm9kZV9tb2R1bGVzL0BzdHVkaW8tZnJlaWdodC9sZW5pcy9kaXN0L2xlbmlzLm1vZGVybi5tanM/NjZiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiB0KCl7cmV0dXJuIHQ9T2JqZWN0LmFzc2lnbj9PYmplY3QuYXNzaWduLmJpbmQoKTpmdW5jdGlvbih0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgaT1hcmd1bWVudHNbZV07Zm9yKHZhciBzIGluIGkpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGkscykmJih0W3NdPWlbc10pfXJldHVybiB0fSx0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBlKHQsZSxpKXtyZXR1cm4gTWF0aC5tYXgodCxNYXRoLm1pbihlLGkpKX1jbGFzcyBpe2FkdmFuY2UodCl7dmFyIGk7aWYoIXRoaXMuaXNSdW5uaW5nKXJldHVybjtsZXQgcz0hMTtpZih0aGlzLmxlcnApdGhpcy52YWx1ZT0oMS0obz10aGlzLmxlcnApKSp0aGlzLnZhbHVlK28qdGhpcy50byxNYXRoLnJvdW5kKHRoaXMudmFsdWUpPT09dGhpcy50byYmKHRoaXMudmFsdWU9dGhpcy50byxzPSEwKTtlbHNle3RoaXMuY3VycmVudFRpbWUrPXQ7Y29uc3QgaT1lKDAsdGhpcy5jdXJyZW50VGltZS90aGlzLmR1cmF0aW9uLDEpO3M9aT49MTtjb25zdCBvPXM/MTp0aGlzLmVhc2luZyhpKTt0aGlzLnZhbHVlPXRoaXMuZnJvbSsodGhpcy50by10aGlzLmZyb20pKm99dmFyIG87bnVsbD09KGk9dGhpcy5vblVwZGF0ZSl8fGkuY2FsbCh0aGlzLHRoaXMudmFsdWUse2NvbXBsZXRlZDpzfSkscyYmdGhpcy5zdG9wKCl9c3RvcCgpe3RoaXMuaXNSdW5uaW5nPSExfWZyb21Ubyh0LGUse2xlcnA6aT0uMSxkdXJhdGlvbjpzPTEsZWFzaW5nOm89KHQ9PnQpLG9uVXBkYXRlOm59KXt0aGlzLmZyb209dGhpcy52YWx1ZT10LHRoaXMudG89ZSx0aGlzLmxlcnA9aSx0aGlzLmR1cmF0aW9uPXMsdGhpcy5lYXNpbmc9byx0aGlzLmN1cnJlbnRUaW1lPTAsdGhpcy5pc1J1bm5pbmc9ITAsdGhpcy5vblVwZGF0ZT1ufX1mdW5jdGlvbiBzKHQsZSl7bGV0IGk7cmV0dXJuIGZ1bmN0aW9uKCl7bGV0IHM9YXJndW1lbnRzLG89dGhpcztjbGVhclRpbWVvdXQoaSksaT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC5hcHBseShvLHMpfSxlKX19Y2xhc3Mgb3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMub25XaW5kb3dSZXNpemU9KCk9Pnt0aGlzLndpZHRoPXdpbmRvdy5pbm5lcldpZHRoLHRoaXMuaGVpZ2h0PXdpbmRvdy5pbm5lckhlaWdodH0sdGhpcy5vbldyYXBwZXJSZXNpemU9KCk9Pnt0aGlzLndpZHRoPXRoaXMud3JhcHBlci5jbGllbnRXaWR0aCx0aGlzLmhlaWdodD10aGlzLndyYXBwZXIuY2xpZW50SGVpZ2h0fSx0aGlzLm9uQ29udGVudFJlc2l6ZT0oKT0+e2NvbnN0IHQ9dGhpcy53cmFwcGVyPT09d2luZG93P2RvY3VtZW50LmRvY3VtZW50RWxlbWVudDp0aGlzLndyYXBwZXI7dGhpcy5zY3JvbGxIZWlnaHQ9dC5zY3JvbGxIZWlnaHQsdGhpcy5zY3JvbGxXaWR0aD10LnNjcm9sbFdpZHRofSx0aGlzLndyYXBwZXI9dCx0aGlzLmNvbnRlbnQ9ZSx0aGlzLndyYXBwZXI9PT13aW5kb3c/KHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5vbldpbmRvd1Jlc2l6ZSwhMSksdGhpcy5vbldpbmRvd1Jlc2l6ZSgpKToodGhpcy53cmFwcGVyUmVzaXplT2JzZXJ2ZXI9bmV3IFJlc2l6ZU9ic2VydmVyKHModGhpcy5vbldyYXBwZXJSZXNpemUsMTAwKSksdGhpcy53cmFwcGVyUmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLndyYXBwZXIpLHRoaXMub25XcmFwcGVyUmVzaXplKCkpLHRoaXMuY29udGVudFJlc2l6ZU9ic2VydmVyPW5ldyBSZXNpemVPYnNlcnZlcihzKHRoaXMub25Db250ZW50UmVzaXplLDEwMCkpLHRoaXMuY29udGVudFJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5jb250ZW50KSx0aGlzLm9uQ29udGVudFJlc2l6ZSgpfWRlc3Ryb3koKXt2YXIgdCxlO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5vbldpbmRvd1Jlc2l6ZSwhMSksbnVsbD09KHQ9dGhpcy53cmFwcGVyUmVzaXplT2JzZXJ2ZXIpfHx0LmRpc2Nvbm5lY3QoKSxudWxsPT0oZT10aGlzLmNvbnRlbnRSZXNpemVPYnNlcnZlcil8fGUuZGlzY29ubmVjdCgpfWdldCBsaW1pdCgpe3JldHVybnt4OnRoaXMuc2Nyb2xsV2lkdGgtdGhpcy53aWR0aCx5OnRoaXMuc2Nyb2xsSGVpZ2h0LXRoaXMuaGVpZ2h0fX19bGV0IG49KCk9Pih7ZXZlbnRzOnt9LGVtaXQodCwuLi5lKXtsZXQgaT10aGlzLmV2ZW50c1t0XXx8W107Zm9yKGxldCB0PTAscz1pLmxlbmd0aDt0PHM7dCsrKWlbdF0oLi4uZSl9LG9uKHQsZSl7dmFyIGk7cmV0dXJuKG51bGw9PShpPXRoaXMuZXZlbnRzW3RdKT92b2lkIDA6aS5wdXNoKGUpKXx8KHRoaXMuZXZlbnRzW3RdPVtlXSksKCk9Pnt2YXIgaTt0aGlzLmV2ZW50c1t0XT1udWxsPT0oaT10aGlzLmV2ZW50c1t0XSk/dm9pZCAwOmkuZmlsdGVyKHQ9PmUhPT10KX19fSk7Y2xhc3Mgcntjb25zdHJ1Y3Rvcih0LHt3aGVlbE11bHRpcGxpZXI6aT0xLHRvdWNoTXVsdGlwbGllcjpzPTIsbm9ybWFsaXplV2hlZWw6bz0hMX0pe3RoaXMub25Ub3VjaFN0YXJ0PXQ9Pntjb25zdHtjbGllbnRYOmUsY2xpZW50WTppfT10LnRhcmdldFRvdWNoZXM/dC50YXJnZXRUb3VjaGVzWzBdOnQ7dGhpcy50b3VjaFN0YXJ0Lng9ZSx0aGlzLnRvdWNoU3RhcnQueT1pLHRoaXMubGFzdERlbHRhPXt4OjAseTowfX0sdGhpcy5vblRvdWNoTW92ZT10PT57Y29uc3R7Y2xpZW50WDplLGNsaWVudFk6aX09dC50YXJnZXRUb3VjaGVzP3QudGFyZ2V0VG91Y2hlc1swXTp0LHM9LShlLXRoaXMudG91Y2hTdGFydC54KSp0aGlzLnRvdWNoTXVsdGlwbGllcixvPS0oaS10aGlzLnRvdWNoU3RhcnQueSkqdGhpcy50b3VjaE11bHRpcGxpZXI7dGhpcy50b3VjaFN0YXJ0Lng9ZSx0aGlzLnRvdWNoU3RhcnQueT1pLHRoaXMubGFzdERlbHRhPXt4OnMseTpvfSx0aGlzLmVtaXR0ZXIuZW1pdChcInNjcm9sbFwiLHt0eXBlOlwidG91Y2hcIixkZWx0YVg6cyxkZWx0YVk6byxldmVudDp0fSl9LHRoaXMub25Ub3VjaEVuZD10PT57dGhpcy5lbWl0dGVyLmVtaXQoXCJzY3JvbGxcIix7dHlwZTpcInRvdWNoXCIsaW5lcnRpYTohMCxkZWx0YVg6dGhpcy5sYXN0RGVsdGEueCxkZWx0YVk6dGhpcy5sYXN0RGVsdGEueSxldmVudDp0fSl9LHRoaXMub25XaGVlbD10PT57bGV0e2RlbHRhWDppLGRlbHRhWTpzfT10O3RoaXMubm9ybWFsaXplV2hlZWwmJihpPWUoLTEwMCxpLDEwMCkscz1lKC0xMDAscywxMDApKSxpKj10aGlzLndoZWVsTXVsdGlwbGllcixzKj10aGlzLndoZWVsTXVsdGlwbGllcix0aGlzLmVtaXR0ZXIuZW1pdChcInNjcm9sbFwiLHt0eXBlOlwid2hlZWxcIixkZWx0YVg6aSxkZWx0YVk6cyxldmVudDp0fSl9LHRoaXMuZWxlbWVudD10LHRoaXMud2hlZWxNdWx0aXBsaWVyPWksdGhpcy50b3VjaE11bHRpcGxpZXI9cyx0aGlzLm5vcm1hbGl6ZVdoZWVsPW8sdGhpcy50b3VjaFN0YXJ0PXt4Om51bGwseTpudWxsfSx0aGlzLmVtaXR0ZXI9bigpLHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIix0aGlzLm9uV2hlZWwse3Bhc3NpdmU6ITF9KSx0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIix0aGlzLm9uVG91Y2hTdGFydCx7cGFzc2l2ZTohMX0pLHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsdGhpcy5vblRvdWNoTW92ZSx7cGFzc2l2ZTohMX0pLHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix0aGlzLm9uVG91Y2hFbmQse3Bhc3NpdmU6ITF9KX1vbih0LGUpe3JldHVybiB0aGlzLmVtaXR0ZXIub24odCxlKX1kZXN0cm95KCl7dGhpcy5lbWl0dGVyLmV2ZW50cz17fSx0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsdGhpcy5vbldoZWVsLHtwYXNzaXZlOiExfSksdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsdGhpcy5vblRvdWNoU3RhcnQse3Bhc3NpdmU6ITF9KSx0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLHRoaXMub25Ub3VjaE1vdmUse3Bhc3NpdmU6ITF9KSx0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsdGhpcy5vblRvdWNoRW5kLHtwYXNzaXZlOiExfSl9fWNsYXNzIGx7Y29uc3RydWN0b3Ioe2RpcmVjdGlvbjplLGdlc3R1cmVEaXJlY3Rpb246cyxtb3VzZU11bHRpcGxpZXI6bCxzbW9vdGg6aCx3cmFwcGVyOmE9d2luZG93LGNvbnRlbnQ6Yz1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsd2hlZWxFdmVudHNUYXJnZXQ6dT1hLHNtb290aFdoZWVsOnA9bnVsbD09aHx8aCxzbW9vdGhUb3VjaDpkPSExLHN5bmNUb3VjaDptPSExLHN5bmNUb3VjaExlcnA6dj0uMSx0b3VjaEluZXJ0aWFNdWx0aXBsaWVyOmc9MzUsZHVyYXRpb246UyxlYXNpbmc6dz0odD0+TWF0aC5taW4oMSwxLjAwMS1NYXRoLnBvdygyLC0xMCp0KSkpLGxlcnA6Zj0oUz9udWxsOi4xKSxpbmZpbml0ZTp5PSExLG9yaWVudGF0aW9uOlQ9KG51bGwhPWU/ZTpcInZlcnRpY2FsXCIpLGdlc3R1cmVPcmllbnRhdGlvbjp6PShudWxsIT1zP3M6XCJ2ZXJ0aWNhbFwiKSx0b3VjaE11bHRpcGxpZXI6TT0xLHdoZWVsTXVsdGlwbGllcjpFPShudWxsIT1sP2w6MSksbm9ybWFsaXplV2hlZWw6TD0hMX09e30pe3RoaXMub25WaXJ0dWFsU2Nyb2xsPSh7dHlwZTplLGluZXJ0aWE6aSxkZWx0YVg6cyxkZWx0YVk6byxldmVudDpufSk9PntpZihuLmN0cmxLZXkpcmV0dXJuO2NvbnN0IHI9XCJ0b3VjaFwiPT09ZSxsPVwid2hlZWxcIj09PWU7aWYoXCJ2ZXJ0aWNhbFwiPT09dGhpcy5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbiYmMD09PW98fFwiaG9yaXpvbnRhbFwiPT09dGhpcy5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbiYmMD09PXN8fHImJlwidmVydGljYWxcIj09PXRoaXMub3B0aW9ucy5nZXN0dXJlT3JpZW50YXRpb24mJjA9PT10aGlzLnNjcm9sbCYmIXRoaXMub3B0aW9ucy5pbmZpbml0ZSYmbzw9MClyZXR1cm47aWYobi5jb21wb3NlZFBhdGgoKS5maW5kKHQ9Pm51bGw9PXR8fG51bGw9PXQuaGFzQXR0cmlidXRlP3ZvaWQgMDp0Lmhhc0F0dHJpYnV0ZShcImRhdGEtbGVuaXMtcHJldmVudFwiKSkpcmV0dXJuO2lmKHRoaXMuaXNTdG9wcGVkfHx0aGlzLmlzTG9ja2VkKXJldHVybiB2b2lkIG4ucHJldmVudERlZmF1bHQoKTtpZih0aGlzLmlzU21vb3RoPSh0aGlzLm9wdGlvbnMuc21vb3RoVG91Y2h8fHRoaXMub3B0aW9ucy5zeW5jVG91Y2gpJiZyfHx0aGlzLm9wdGlvbnMuc21vb3RoV2hlZWwmJmwsIXRoaXMuaXNTbW9vdGgpcmV0dXJuIHRoaXMuaXNTY3JvbGxpbmc9ITEsdm9pZCB0aGlzLmFuaW1hdGUuc3RvcCgpO24ucHJldmVudERlZmF1bHQoKTtsZXQgaD1vO1wiYm90aFwiPT09dGhpcy5vcHRpb25zLmdlc3R1cmVPcmllbnRhdGlvbj9oPU1hdGguYWJzKG8pPk1hdGguYWJzKHMpP286czpcImhvcml6b250YWxcIj09PXRoaXMub3B0aW9ucy5nZXN0dXJlT3JpZW50YXRpb24mJihoPXMpO2NvbnN0IGE9ciYmdGhpcy5vcHRpb25zLnN5bmNUb3VjaCxjPXImJmkmJk1hdGguYWJzKGgpPjE7YyYmKGg9dGhpcy52ZWxvY2l0eSp0aGlzLm9wdGlvbnMudG91Y2hJbmVydGlhTXVsdGlwbGllciksdGhpcy5zY3JvbGxUbyh0aGlzLnRhcmdldFNjcm9sbCtoLHQoe3Byb2dyYW1tYXRpYzohMX0sYSYme2xlcnA6Yz90aGlzLnN5bmNUb3VjaExlcnA6LjR9KSl9LHRoaXMub25TY3JvbGw9KCk9PntpZighdGhpcy5pc1Njcm9sbGluZyl7Y29uc3QgdD10aGlzLmFuaW1hdGVkU2Nyb2xsO3RoaXMuYW5pbWF0ZWRTY3JvbGw9dGhpcy50YXJnZXRTY3JvbGw9dGhpcy5hY3R1YWxTY3JvbGwsdGhpcy52ZWxvY2l0eT0wLHRoaXMuZGlyZWN0aW9uPU1hdGguc2lnbih0aGlzLmFuaW1hdGVkU2Nyb2xsLXQpLHRoaXMuZW1pdCgpfX0sZSYmY29uc29sZS53YXJuKFwiTGVuaXM6IGBkaXJlY3Rpb25gIG9wdGlvbiBpcyBkZXByZWNhdGVkLCB1c2UgYG9yaWVudGF0aW9uYCBpbnN0ZWFkXCIpLHMmJmNvbnNvbGUud2FybihcIkxlbmlzOiBgZ2VzdHVyZURpcmVjdGlvbmAgb3B0aW9uIGlzIGRlcHJlY2F0ZWQsIHVzZSBgZ2VzdHVyZU9yaWVudGF0aW9uYCBpbnN0ZWFkXCIpLGwmJmNvbnNvbGUud2FybihcIkxlbmlzOiBgbW91c2VNdWx0aXBsaWVyYCBvcHRpb24gaXMgZGVwcmVjYXRlZCwgdXNlIGB3aGVlbE11bHRpcGxpZXJgIGluc3RlYWRcIiksaCYmY29uc29sZS53YXJuKFwiTGVuaXM6IGBzbW9vdGhgIG9wdGlvbiBpcyBkZXByZWNhdGVkLCB1c2UgYHNtb290aFdoZWVsYCBpbnN0ZWFkXCIpLHdpbmRvdy5sZW5pc1ZlcnNpb249XCIxLjAuMTFcIixhIT09ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZhIT09ZG9jdW1lbnQuYm9keXx8KGE9d2luZG93KSx0aGlzLm9wdGlvbnM9e3dyYXBwZXI6YSxjb250ZW50OmMsd2hlZWxFdmVudHNUYXJnZXQ6dSxzbW9vdGhXaGVlbDpwLHNtb290aFRvdWNoOmQsc3luY1RvdWNoOm0sc3luY1RvdWNoTGVycDp2LHRvdWNoSW5lcnRpYU11bHRpcGxpZXI6ZyxkdXJhdGlvbjpTLGVhc2luZzp3LGxlcnA6ZixpbmZpbml0ZTp5LGdlc3R1cmVPcmllbnRhdGlvbjp6LG9yaWVudGF0aW9uOlQsdG91Y2hNdWx0aXBsaWVyOk0sd2hlZWxNdWx0aXBsaWVyOkUsbm9ybWFsaXplV2hlZWw6TH0sdGhpcy5kaW1lbnNpb25zPW5ldyBvKGEsYyksdGhpcy5yb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibGVuaXNcIiksdGhpcy52ZWxvY2l0eT0wLHRoaXMuaXNTdG9wcGVkPSExLHRoaXMuaXNTbW9vdGg9cHx8ZCx0aGlzLmlzU2Nyb2xsaW5nPSExLHRoaXMudGFyZ2V0U2Nyb2xsPXRoaXMuYW5pbWF0ZWRTY3JvbGw9dGhpcy5hY3R1YWxTY3JvbGwsdGhpcy5hbmltYXRlPW5ldyBpLHRoaXMuZW1pdHRlcj1uKCksdGhpcy5vcHRpb25zLndyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXMub25TY3JvbGwse3Bhc3NpdmU6ITF9KSx0aGlzLnZpcnR1YWxTY3JvbGw9bmV3IHIodSx7dG91Y2hNdWx0aXBsaWVyOk0sd2hlZWxNdWx0aXBsaWVyOkUsbm9ybWFsaXplV2hlZWw6TH0pLHRoaXMudmlydHVhbFNjcm9sbC5vbihcInNjcm9sbFwiLHRoaXMub25WaXJ0dWFsU2Nyb2xsKX1kZXN0cm95KCl7dGhpcy5lbWl0dGVyLmV2ZW50cz17fSx0aGlzLm9wdGlvbnMud3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsdGhpcy5vblNjcm9sbCx7cGFzc2l2ZTohMX0pLHRoaXMudmlydHVhbFNjcm9sbC5kZXN0cm95KCl9b24odCxlKXtyZXR1cm4gdGhpcy5lbWl0dGVyLm9uKHQsZSl9b2ZmKHQsZSl7dmFyIGk7dGhpcy5lbWl0dGVyLmV2ZW50c1t0XT1udWxsPT0oaT10aGlzLmVtaXR0ZXIuZXZlbnRzW3RdKT92b2lkIDA6aS5maWx0ZXIodD0+ZSE9PXQpfXNldFNjcm9sbCh0KXt0aGlzLmlzSG9yaXpvbnRhbD90aGlzLnJvb3RFbGVtZW50LnNjcm9sbExlZnQ9dDp0aGlzLnJvb3RFbGVtZW50LnNjcm9sbFRvcD10fWVtaXQoKXt0aGlzLmVtaXR0ZXIuZW1pdChcInNjcm9sbFwiLHRoaXMpfXJlc2V0KCl7dGhpcy5pc0xvY2tlZD0hMSx0aGlzLmlzU2Nyb2xsaW5nPSExLHRoaXMudmVsb2NpdHk9MCx0aGlzLmFuaW1hdGUuc3RvcCgpfXN0YXJ0KCl7dGhpcy5pc1N0b3BwZWQ9ITEsdGhpcy5yZXNldCgpfXN0b3AoKXt0aGlzLmlzU3RvcHBlZD0hMCx0aGlzLmFuaW1hdGUuc3RvcCgpLHRoaXMucmVzZXQoKX1yYWYodCl7Y29uc3QgZT10LSh0aGlzLnRpbWV8fHQpO3RoaXMudGltZT10LHRoaXMuYW5pbWF0ZS5hZHZhbmNlKC4wMDEqZSl9c2Nyb2xsVG8odCx7b2Zmc2V0Omk9MCxpbW1lZGlhdGU6cz0hMSxsb2NrOm89ITEsZHVyYXRpb246bj10aGlzLm9wdGlvbnMuZHVyYXRpb24sZWFzaW5nOnI9dGhpcy5vcHRpb25zLmVhc2luZyxsZXJwOmw9IW4mJnRoaXMub3B0aW9ucy5sZXJwLG9uQ29tcGxldGU6aD1udWxsLGZvcmNlOmE9ITEscHJvZ3JhbW1hdGljOmM9ITB9PXt9KXtpZighdGhpcy5pc1N0b3BwZWR8fGEpe2lmKFtcInRvcFwiLFwibGVmdFwiLFwic3RhcnRcIl0uaW5jbHVkZXModCkpdD0wO2Vsc2UgaWYoW1wiYm90dG9tXCIsXCJyaWdodFwiLFwiZW5kXCJdLmluY2x1ZGVzKHQpKXQ9dGhpcy5saW1pdDtlbHNle3ZhciB1O2xldCBlO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0P2U9ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KTpudWxsIT0odT10KSYmdS5ub2RlVHlwZSYmKGU9dCksZSl7aWYodGhpcy5vcHRpb25zLndyYXBwZXIhPT13aW5kb3cpe2NvbnN0IHQ9dGhpcy5vcHRpb25zLndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7aS09dGhpcy5pc0hvcml6b250YWw/dC5sZWZ0OnQudG9wfWNvbnN0IHM9ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt0PSh0aGlzLmlzSG9yaXpvbnRhbD9zLmxlZnQ6cy50b3ApK3RoaXMuYW5pbWF0ZWRTY3JvbGx9fWlmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXtpZih0Kz1pLHQ9TWF0aC5yb3VuZCh0KSx0aGlzLm9wdGlvbnMuaW5maW5pdGU/YyYmKHRoaXMudGFyZ2V0U2Nyb2xsPXRoaXMuYW5pbWF0ZWRTY3JvbGw9dGhpcy5zY3JvbGwpOnQ9ZSgwLHQsdGhpcy5saW1pdCkscylyZXR1cm4gdGhpcy5hbmltYXRlZFNjcm9sbD10aGlzLnRhcmdldFNjcm9sbD10LHRoaXMuc2V0U2Nyb2xsKHRoaXMuc2Nyb2xsKSx0aGlzLnJlc2V0KCksdGhpcy5lbWl0KCksdm9pZChudWxsPT1ofHxoKCkpO2lmKCFjKXtpZih0PT09dGhpcy50YXJnZXRTY3JvbGwpcmV0dXJuO3RoaXMudGFyZ2V0U2Nyb2xsPXR9dGhpcy5hbmltYXRlLmZyb21Ubyh0aGlzLmFuaW1hdGVkU2Nyb2xsLHQse2R1cmF0aW9uOm4sZWFzaW5nOnIsbGVycDpsLG9uVXBkYXRlOih0LHtjb21wbGV0ZWQ6ZX0pPT57byYmKHRoaXMuaXNMb2NrZWQ9ITApLHRoaXMuaXNTY3JvbGxpbmc9ITAsdGhpcy52ZWxvY2l0eT10LXRoaXMuYW5pbWF0ZWRTY3JvbGwsdGhpcy5kaXJlY3Rpb249TWF0aC5zaWduKHRoaXMudmVsb2NpdHkpLHRoaXMuYW5pbWF0ZWRTY3JvbGw9dCx0aGlzLnNldFNjcm9sbCh0aGlzLnNjcm9sbCksYyYmKHRoaXMudGFyZ2V0U2Nyb2xsPXQpLGUmJihvJiYodGhpcy5pc0xvY2tlZD0hMSkscmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpPT57dGhpcy5pc1Njcm9sbGluZz0hMX0pLHRoaXMudmVsb2NpdHk9MCxudWxsPT1ofHxoKCkpLHRoaXMuZW1pdCgpfX0pfX19Z2V0IHJvb3RFbGVtZW50KCl7cmV0dXJuIHRoaXMub3B0aW9ucy53cmFwcGVyPT09d2luZG93P3RoaXMub3B0aW9ucy5jb250ZW50OnRoaXMub3B0aW9ucy53cmFwcGVyfWdldCBsaW1pdCgpe3JldHVybiB0aGlzLmlzSG9yaXpvbnRhbD90aGlzLmRpbWVuc2lvbnMubGltaXQueDp0aGlzLmRpbWVuc2lvbnMubGltaXQueX1nZXQgaXNIb3Jpem9udGFsKCl7cmV0dXJuXCJob3Jpem9udGFsXCI9PT10aGlzLm9wdGlvbnMub3JpZW50YXRpb259Z2V0IGFjdHVhbFNjcm9sbCgpe3JldHVybiB0aGlzLmlzSG9yaXpvbnRhbD90aGlzLnJvb3RFbGVtZW50LnNjcm9sbExlZnQ6dGhpcy5yb290RWxlbWVudC5zY3JvbGxUb3B9Z2V0IHNjcm9sbCgpe3JldHVybiB0aGlzLm9wdGlvbnMuaW5maW5pdGU/ZnVuY3Rpb24odCxlKXtsZXQgaT10JWU7cmV0dXJuKGU+MCYmaTwwfHxlPDAmJmk+MCkmJihpKz1lKSxpfSh0aGlzLmFuaW1hdGVkU2Nyb2xsLHRoaXMubGltaXQpOnRoaXMuYW5pbWF0ZWRTY3JvbGx9Z2V0IHByb2dyZXNzKCl7cmV0dXJuIDA9PT10aGlzLmxpbWl0PzE6dGhpcy5zY3JvbGwvdGhpcy5saW1pdH1nZXQgaXNTbW9vdGgoKXtyZXR1cm4gdGhpcy5fX2lzU21vb3RofXNldCBpc1Ntb290aCh0KXt0aGlzLl9faXNTbW9vdGghPT10JiYodGhpcy5yb290RWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFwibGVuaXMtc21vb3RoXCIsdCksdGhpcy5fX2lzU21vb3RoPXQpfWdldCBpc1Njcm9sbGluZygpe3JldHVybiB0aGlzLl9faXNTY3JvbGxpbmd9c2V0IGlzU2Nyb2xsaW5nKHQpe3RoaXMuX19pc1Njcm9sbGluZyE9PXQmJih0aGlzLnJvb3RFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJsZW5pcy1zY3JvbGxpbmdcIix0KSx0aGlzLl9faXNTY3JvbGxpbmc9dCl9Z2V0IGlzU3RvcHBlZCgpe3JldHVybiB0aGlzLl9faXNTdG9wcGVkfXNldCBpc1N0b3BwZWQodCl7dGhpcy5fX2lzU3RvcHBlZCE9PXQmJih0aGlzLnJvb3RFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJsZW5pcy1zdG9wcGVkXCIsdCksdGhpcy5fX2lzU3RvcHBlZD10KX19ZXhwb3J0e2wgYXMgZGVmYXVsdH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZW5pcy5tb2Rlcm4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/locomotive-scroll/node_modules/@studio-freight/lenis/dist/lenis.modern.mjs\n");

/***/ })

};
;